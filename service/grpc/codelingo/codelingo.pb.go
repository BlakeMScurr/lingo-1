// Code generated by protoc-gen-go.
// source: codelingo.proto
// DO NOT EDIT!

/*
Package codelingo is a generated protocol buffer package.

It is generated from these files:
	codelingo.proto

It has these top-level messages:
	DescribeFactRequest
	DescribeFactReply
	Property
	PathsFromOffsetRequest
	PathsFromOffsetReply
	Path
	ListFactsRequest
	FactList
	Children
	ListLexiconsRequest
	ListLexiconsReply
	SessionRequest
	SessionReply
	QueryRequest
	MetaDatum
	Fact
	Argument
	IntComparison
	FloatComparison
	FactSet
	Lexicon
	QueryReply
	ReviewRequest
	Issue
	IssueRange
	Position
	LatestClientVersionRequest
	LatestClientVersionReply
*/
package codelingo

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DescribeFactRequest struct {
	Owner   string `protobuf:"bytes,1,opt,name=owner" json:"owner,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
	Fact    string `protobuf:"bytes,4,opt,name=fact" json:"fact,omitempty"`
}

func (m *DescribeFactRequest) Reset()                    { *m = DescribeFactRequest{} }
func (m *DescribeFactRequest) String() string            { return proto.CompactTextString(m) }
func (*DescribeFactRequest) ProtoMessage()               {}
func (*DescribeFactRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DescribeFactRequest) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *DescribeFactRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DescribeFactRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *DescribeFactRequest) GetFact() string {
	if m != nil {
		return m.Fact
	}
	return ""
}

type DescribeFactReply struct {
	Description string      `protobuf:"bytes,1,opt,name=description" json:"description,omitempty"`
	Examples    string      `protobuf:"bytes,2,opt,name=examples" json:"examples,omitempty"`
	Properties  []*Property `protobuf:"bytes,3,rep,name=properties" json:"properties,omitempty"`
}

func (m *DescribeFactReply) Reset()                    { *m = DescribeFactReply{} }
func (m *DescribeFactReply) String() string            { return proto.CompactTextString(m) }
func (*DescribeFactReply) ProtoMessage()               {}
func (*DescribeFactReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DescribeFactReply) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DescribeFactReply) GetExamples() string {
	if m != nil {
		return m.Examples
	}
	return ""
}

func (m *DescribeFactReply) GetProperties() []*Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

type Property struct {
	Name        string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
}

func (m *Property) Reset()                    { *m = Property{} }
func (m *Property) String() string            { return proto.CompactTextString(m) }
func (*Property) ProtoMessage()               {}
func (*Property) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Property) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Property) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type PathsFromOffsetRequest struct {
	Lang     string `protobuf:"bytes,1,opt,name=lang" json:"lang,omitempty"`
	Dir      string `protobuf:"bytes,2,opt,name=dir" json:"dir,omitempty"`
	Filename string `protobuf:"bytes,3,opt,name=filename" json:"filename,omitempty"`
	Src      string `protobuf:"bytes,4,opt,name=src" json:"src,omitempty"`
	Start    int64  `protobuf:"varint,5,opt,name=start" json:"start,omitempty"`
	End      int64  `protobuf:"varint,6,opt,name=end" json:"end,omitempty"`
}

func (m *PathsFromOffsetRequest) Reset()                    { *m = PathsFromOffsetRequest{} }
func (m *PathsFromOffsetRequest) String() string            { return proto.CompactTextString(m) }
func (*PathsFromOffsetRequest) ProtoMessage()               {}
func (*PathsFromOffsetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *PathsFromOffsetRequest) GetLang() string {
	if m != nil {
		return m.Lang
	}
	return ""
}

func (m *PathsFromOffsetRequest) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *PathsFromOffsetRequest) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *PathsFromOffsetRequest) GetSrc() string {
	if m != nil {
		return m.Src
	}
	return ""
}

func (m *PathsFromOffsetRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *PathsFromOffsetRequest) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

type PathsFromOffsetReply struct {
	Paths []*Path `protobuf:"bytes,1,rep,name=paths" json:"paths,omitempty"`
}

func (m *PathsFromOffsetReply) Reset()                    { *m = PathsFromOffsetReply{} }
func (m *PathsFromOffsetReply) String() string            { return proto.CompactTextString(m) }
func (*PathsFromOffsetReply) ProtoMessage()               {}
func (*PathsFromOffsetReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PathsFromOffsetReply) GetPaths() []*Path {
	if m != nil {
		return m.Paths
	}
	return nil
}

type Path struct {
	Nodes []string `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Path) GetNodes() []string {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type ListFactsRequest struct {
	Owner   string `protobuf:"bytes,1,opt,name=owner" json:"owner,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
}

func (m *ListFactsRequest) Reset()                    { *m = ListFactsRequest{} }
func (m *ListFactsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListFactsRequest) ProtoMessage()               {}
func (*ListFactsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ListFactsRequest) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *ListFactsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListFactsRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type FactList struct {
	Facts map[string]*Children `protobuf:"bytes,1,rep,name=facts" json:"facts,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FactList) Reset()                    { *m = FactList{} }
func (m *FactList) String() string            { return proto.CompactTextString(m) }
func (*FactList) ProtoMessage()               {}
func (*FactList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *FactList) GetFacts() map[string]*Children {
	if m != nil {
		return m.Facts
	}
	return nil
}

type Children struct {
	Child []string `protobuf:"bytes,1,rep,name=child" json:"child,omitempty"`
}

func (m *Children) Reset()                    { *m = Children{} }
func (m *Children) String() string            { return proto.CompactTextString(m) }
func (*Children) ProtoMessage()               {}
func (*Children) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Children) GetChild() []string {
	if m != nil {
		return m.Child
	}
	return nil
}

type ListLexiconsRequest struct {
}

func (m *ListLexiconsRequest) Reset()                    { *m = ListLexiconsRequest{} }
func (m *ListLexiconsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListLexiconsRequest) ProtoMessage()               {}
func (*ListLexiconsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type ListLexiconsReply struct {
	Lexicons []string `protobuf:"bytes,1,rep,name=lexicons" json:"lexicons,omitempty"`
}

func (m *ListLexiconsReply) Reset()                    { *m = ListLexiconsReply{} }
func (m *ListLexiconsReply) String() string            { return proto.CompactTextString(m) }
func (*ListLexiconsReply) ProtoMessage()               {}
func (*ListLexiconsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ListLexiconsReply) GetLexicons() []string {
	if m != nil {
		return m.Lexicons
	}
	return nil
}

type SessionRequest struct {
}

func (m *SessionRequest) Reset()                    { *m = SessionRequest{} }
func (m *SessionRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionRequest) ProtoMessage()               {}
func (*SessionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type SessionReply struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *SessionReply) Reset()                    { *m = SessionReply{} }
func (m *SessionReply) String() string            { return proto.CompactTextString(m) }
func (*SessionReply) ProtoMessage()               {}
func (*SessionReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SessionReply) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// The request message containing the CLQL source code.
type QueryRequest struct {
	FactTree *Fact                 `protobuf:"bytes,1,opt,name=factTree" json:"factTree,omitempty"`
	Lexicons []*Lexicon            `protobuf:"bytes,2,rep,name=lexicons" json:"lexicons,omitempty"`
	Metadata map[string]*MetaDatum `protobuf:"bytes,3,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *QueryRequest) Reset()                    { *m = QueryRequest{} }
func (m *QueryRequest) String() string            { return proto.CompactTextString(m) }
func (*QueryRequest) ProtoMessage()               {}
func (*QueryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *QueryRequest) GetFactTree() *Fact {
	if m != nil {
		return m.FactTree
	}
	return nil
}

func (m *QueryRequest) GetLexicons() []*Lexicon {
	if m != nil {
		return m.Lexicons
	}
	return nil
}

func (m *QueryRequest) GetMetadata() map[string]*MetaDatum {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// Possible values correspond with in platform/controller/graphdb/query/result
type MetaDatum struct {
	// Types that are valid to be assigned to Datum:
	//	*MetaDatum_String_
	//	*MetaDatum_Int
	//	*MetaDatum_Bool
	Datum isMetaDatum_Datum `protobuf_oneof:"datum"`
}

func (m *MetaDatum) Reset()                    { *m = MetaDatum{} }
func (m *MetaDatum) String() string            { return proto.CompactTextString(m) }
func (*MetaDatum) ProtoMessage()               {}
func (*MetaDatum) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type isMetaDatum_Datum interface {
	isMetaDatum_Datum()
}

type MetaDatum_String_ struct {
	String_ string `protobuf:"bytes,1,opt,name=string,oneof"`
}
type MetaDatum_Int struct {
	Int int64 `protobuf:"varint,2,opt,name=int,oneof"`
}
type MetaDatum_Bool struct {
	Bool bool `protobuf:"varint,3,opt,name=bool,oneof"`
}

func (*MetaDatum_String_) isMetaDatum_Datum() {}
func (*MetaDatum_Int) isMetaDatum_Datum()     {}
func (*MetaDatum_Bool) isMetaDatum_Datum()    {}

func (m *MetaDatum) GetDatum() isMetaDatum_Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

func (m *MetaDatum) GetString_() string {
	if x, ok := m.GetDatum().(*MetaDatum_String_); ok {
		return x.String_
	}
	return ""
}

func (m *MetaDatum) GetInt() int64 {
	if x, ok := m.GetDatum().(*MetaDatum_Int); ok {
		return x.Int
	}
	return 0
}

func (m *MetaDatum) GetBool() bool {
	if x, ok := m.GetDatum().(*MetaDatum_Bool); ok {
		return x.Bool
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MetaDatum) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MetaDatum_OneofMarshaler, _MetaDatum_OneofUnmarshaler, _MetaDatum_OneofSizer, []interface{}{
		(*MetaDatum_String_)(nil),
		(*MetaDatum_Int)(nil),
		(*MetaDatum_Bool)(nil),
	}
}

func _MetaDatum_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MetaDatum)
	// datum
	switch x := m.Datum.(type) {
	case *MetaDatum_String_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.String_)
	case *MetaDatum_Int:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Int))
	case *MetaDatum_Bool:
		t := uint64(0)
		if x.Bool {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("MetaDatum.Datum has unexpected type %T", x)
	}
	return nil
}

func _MetaDatum_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MetaDatum)
	switch tag {
	case 1: // datum.string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Datum = &MetaDatum_String_{x}
		return true, err
	case 2: // datum.int
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Datum = &MetaDatum_Int{int64(x)}
		return true, err
	case 3: // datum.bool
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Datum = &MetaDatum_Bool{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _MetaDatum_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MetaDatum)
	// datum
	switch x := m.Datum.(type) {
	case *MetaDatum_String_:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.String_)))
		n += len(x.String_)
	case *MetaDatum_Int:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int))
	case *MetaDatum_Bool:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Fact struct {
	Namespace string    `protobuf:"bytes,1,opt,name=Namespace" json:"Namespace,omitempty"`
	Name      string    `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	LexiconID string    `protobuf:"bytes,3,opt,name=LexiconID" json:"LexiconID,omitempty"`
	Negated   bool      `protobuf:"varint,4,opt,name=Negated" json:"Negated,omitempty"`
	Depth     int64     `protobuf:"varint,5,opt,name=Depth" json:"Depth,omitempty"`
	Yield     bool      `protobuf:"varint,6,opt,name=Yield" json:"Yield,omitempty"`
	Arg       *Argument `protobuf:"bytes,7,opt,name=Arg" json:"Arg,omitempty"`
}

func (m *Fact) Reset()                    { *m = Fact{} }
func (m *Fact) String() string            { return proto.CompactTextString(m) }
func (*Fact) ProtoMessage()               {}
func (*Fact) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Fact) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Fact) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Fact) GetLexiconID() string {
	if m != nil {
		return m.LexiconID
	}
	return ""
}

func (m *Fact) GetNegated() bool {
	if m != nil {
		return m.Negated
	}
	return false
}

func (m *Fact) GetDepth() int64 {
	if m != nil {
		return m.Depth
	}
	return 0
}

func (m *Fact) GetYield() bool {
	if m != nil {
		return m.Yield
	}
	return false
}

func (m *Fact) GetArg() *Argument {
	if m != nil {
		return m.Arg
	}
	return nil
}

type Argument struct {
	// Types that are valid to be assigned to Arg:
	//	*Argument_Stringarg
	//	*Argument_Regexarg
	//	*Argument_Vararg
	//	*Argument_Intcomparisonarg
	//	*Argument_Floatcomparisonarg
	//	*Argument_Factlistarg
	Arg isArgument_Arg `protobuf_oneof:"arg"`
}

func (m *Argument) Reset()                    { *m = Argument{} }
func (m *Argument) String() string            { return proto.CompactTextString(m) }
func (*Argument) ProtoMessage()               {}
func (*Argument) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

type isArgument_Arg interface {
	isArgument_Arg()
}

type Argument_Stringarg struct {
	Stringarg string `protobuf:"bytes,1,opt,name=stringarg,oneof"`
}
type Argument_Regexarg struct {
	Regexarg string `protobuf:"bytes,2,opt,name=regexarg,oneof"`
}
type Argument_Vararg struct {
	Vararg string `protobuf:"bytes,3,opt,name=vararg,oneof"`
}
type Argument_Intcomparisonarg struct {
	Intcomparisonarg *IntComparison `protobuf:"bytes,4,opt,name=Intcomparisonarg,oneof"`
}
type Argument_Floatcomparisonarg struct {
	Floatcomparisonarg *FloatComparison `protobuf:"bytes,5,opt,name=floatcomparisonarg,oneof"`
}
type Argument_Factlistarg struct {
	Factlistarg *FactSet `protobuf:"bytes,6,opt,name=factlistarg,oneof"`
}

func (*Argument_Stringarg) isArgument_Arg()          {}
func (*Argument_Regexarg) isArgument_Arg()           {}
func (*Argument_Vararg) isArgument_Arg()             {}
func (*Argument_Intcomparisonarg) isArgument_Arg()   {}
func (*Argument_Floatcomparisonarg) isArgument_Arg() {}
func (*Argument_Factlistarg) isArgument_Arg()        {}

func (m *Argument) GetArg() isArgument_Arg {
	if m != nil {
		return m.Arg
	}
	return nil
}

func (m *Argument) GetStringarg() string {
	if x, ok := m.GetArg().(*Argument_Stringarg); ok {
		return x.Stringarg
	}
	return ""
}

func (m *Argument) GetRegexarg() string {
	if x, ok := m.GetArg().(*Argument_Regexarg); ok {
		return x.Regexarg
	}
	return ""
}

func (m *Argument) GetVararg() string {
	if x, ok := m.GetArg().(*Argument_Vararg); ok {
		return x.Vararg
	}
	return ""
}

func (m *Argument) GetIntcomparisonarg() *IntComparison {
	if x, ok := m.GetArg().(*Argument_Intcomparisonarg); ok {
		return x.Intcomparisonarg
	}
	return nil
}

func (m *Argument) GetFloatcomparisonarg() *FloatComparison {
	if x, ok := m.GetArg().(*Argument_Floatcomparisonarg); ok {
		return x.Floatcomparisonarg
	}
	return nil
}

func (m *Argument) GetFactlistarg() *FactSet {
	if x, ok := m.GetArg().(*Argument_Factlistarg); ok {
		return x.Factlistarg
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Argument) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Argument_OneofMarshaler, _Argument_OneofUnmarshaler, _Argument_OneofSizer, []interface{}{
		(*Argument_Stringarg)(nil),
		(*Argument_Regexarg)(nil),
		(*Argument_Vararg)(nil),
		(*Argument_Intcomparisonarg)(nil),
		(*Argument_Floatcomparisonarg)(nil),
		(*Argument_Factlistarg)(nil),
	}
}

func _Argument_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Argument)
	// arg
	switch x := m.Arg.(type) {
	case *Argument_Stringarg:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Stringarg)
	case *Argument_Regexarg:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Regexarg)
	case *Argument_Vararg:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Vararg)
	case *Argument_Intcomparisonarg:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Intcomparisonarg); err != nil {
			return err
		}
	case *Argument_Floatcomparisonarg:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Floatcomparisonarg); err != nil {
			return err
		}
	case *Argument_Factlistarg:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Factlistarg); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Argument.Arg has unexpected type %T", x)
	}
	return nil
}

func _Argument_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Argument)
	switch tag {
	case 1: // arg.stringarg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Arg = &Argument_Stringarg{x}
		return true, err
	case 2: // arg.regexarg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Arg = &Argument_Regexarg{x}
		return true, err
	case 3: // arg.vararg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Arg = &Argument_Vararg{x}
		return true, err
	case 4: // arg.Intcomparisonarg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IntComparison)
		err := b.DecodeMessage(msg)
		m.Arg = &Argument_Intcomparisonarg{msg}
		return true, err
	case 5: // arg.floatcomparisonarg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FloatComparison)
		err := b.DecodeMessage(msg)
		m.Arg = &Argument_Floatcomparisonarg{msg}
		return true, err
	case 6: // arg.factlistarg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FactSet)
		err := b.DecodeMessage(msg)
		m.Arg = &Argument_Factlistarg{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Argument_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Argument)
	// arg
	switch x := m.Arg.(type) {
	case *Argument_Stringarg:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Stringarg)))
		n += len(x.Stringarg)
	case *Argument_Regexarg:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Regexarg)))
		n += len(x.Regexarg)
	case *Argument_Vararg:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Vararg)))
		n += len(x.Vararg)
	case *Argument_Intcomparisonarg:
		s := proto.Size(x.Intcomparisonarg)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Argument_Floatcomparisonarg:
		s := proto.Size(x.Floatcomparisonarg)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Argument_Factlistarg:
		s := proto.Size(x.Factlistarg)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type IntComparison struct {
	Value      int64  `protobuf:"varint,1,opt,name=value" json:"value,omitempty"`
	Comparison string `protobuf:"bytes,2,opt,name=comparison" json:"comparison,omitempty"`
}

func (m *IntComparison) Reset()                    { *m = IntComparison{} }
func (m *IntComparison) String() string            { return proto.CompactTextString(m) }
func (*IntComparison) ProtoMessage()               {}
func (*IntComparison) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *IntComparison) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *IntComparison) GetComparison() string {
	if m != nil {
		return m.Comparison
	}
	return ""
}

type FloatComparison struct {
	Value      float32 `protobuf:"fixed32,1,opt,name=value" json:"value,omitempty"`
	Comparison string  `protobuf:"bytes,2,opt,name=comparison" json:"comparison,omitempty"`
}

func (m *FloatComparison) Reset()                    { *m = FloatComparison{} }
func (m *FloatComparison) String() string            { return proto.CompactTextString(m) }
func (*FloatComparison) ProtoMessage()               {}
func (*FloatComparison) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *FloatComparison) GetValue() float32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *FloatComparison) GetComparison() string {
	if m != nil {
		return m.Comparison
	}
	return ""
}

// TODO: resolve naming conflict with FactList
type FactSet struct {
	List []*Fact `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *FactSet) Reset()                    { *m = FactSet{} }
func (m *FactSet) String() string            { return proto.CompactTextString(m) }
func (*FactSet) ProtoMessage()               {}
func (*FactSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *FactSet) GetList() []*Fact {
	if m != nil {
		return m.List
	}
	return nil
}

type Lexicon struct {
	Version string `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	Owner   string `protobuf:"bytes,2,opt,name=owner" json:"owner,omitempty"`
	Name    string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
}

func (m *Lexicon) Reset()                    { *m = Lexicon{} }
func (m *Lexicon) String() string            { return proto.CompactTextString(m) }
func (*Lexicon) ProtoMessage()               {}
func (*Lexicon) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *Lexicon) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Lexicon) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Lexicon) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// The query response.
type QueryReply struct {
	Id       string                          `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Kind     []string                        `protobuf:"bytes,2,rep,name=kind" json:"kind,omitempty"`
	Data     map[string]*QueryReply_DataList `protobuf:"bytes,3,rep,name=data" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Metadata map[string]*QueryReply_DataList `protobuf:"bytes,4,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Error    string                          `protobuf:"bytes,5,opt,name=error" json:"error,omitempty"`
}

func (m *QueryReply) Reset()                    { *m = QueryReply{} }
func (m *QueryReply) String() string            { return proto.CompactTextString(m) }
func (*QueryReply) ProtoMessage()               {}
func (*QueryReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *QueryReply) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *QueryReply) GetKind() []string {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *QueryReply) GetData() map[string]*QueryReply_DataList {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *QueryReply) GetMetadata() map[string]*QueryReply_DataList {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *QueryReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type QueryReply_DataList struct {
	Data []string `protobuf:"bytes,1,rep,name=data" json:"data,omitempty"`
}

func (m *QueryReply_DataList) Reset()                    { *m = QueryReply_DataList{} }
func (m *QueryReply_DataList) String() string            { return proto.CompactTextString(m) }
func (*QueryReply_DataList) ProtoMessage()               {}
func (*QueryReply_DataList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 0} }

func (m *QueryReply_DataList) GetData() []string {
	if m != nil {
		return m.Data
	}
	return nil
}

// The request message containing the files or directories to review.
type ReviewRequest struct {
	Host          string   `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	Hostname      string   `protobuf:"bytes,2,opt,name=hostname" json:"hostname,omitempty"`
	Owner         string   `protobuf:"bytes,3,opt,name=owner" json:"owner,omitempty"`
	Repo          string   `protobuf:"bytes,4,opt,name=repo" json:"repo,omitempty"`
	Sha           string   `protobuf:"bytes,5,opt,name=sha" json:"sha,omitempty"`
	Patches       []string `protobuf:"bytes,6,rep,name=Patches" json:"Patches,omitempty"`
	IsPullRequest bool     `protobuf:"varint,7,opt,name=isPullRequest" json:"isPullRequest,omitempty"`
	PullRequestID int64    `protobuf:"varint,8,opt,name=pullRequestID" json:"pullRequestID,omitempty"`
	Vcs           string   `protobuf:"bytes,9,opt,name=vcs" json:"vcs,omitempty"`
	Dotlingo      string   `protobuf:"bytes,10,opt,name=dotlingo" json:"dotlingo,omitempty"`
	Dir           string   `protobuf:"bytes,11,opt,name=dir" json:"dir,omitempty"`
}

func (m *ReviewRequest) Reset()                    { *m = ReviewRequest{} }
func (m *ReviewRequest) String() string            { return proto.CompactTextString(m) }
func (*ReviewRequest) ProtoMessage()               {}
func (*ReviewRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *ReviewRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *ReviewRequest) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *ReviewRequest) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *ReviewRequest) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *ReviewRequest) GetSha() string {
	if m != nil {
		return m.Sha
	}
	return ""
}

func (m *ReviewRequest) GetPatches() []string {
	if m != nil {
		return m.Patches
	}
	return nil
}

func (m *ReviewRequest) GetIsPullRequest() bool {
	if m != nil {
		return m.IsPullRequest
	}
	return false
}

func (m *ReviewRequest) GetPullRequestID() int64 {
	if m != nil {
		return m.PullRequestID
	}
	return 0
}

func (m *ReviewRequest) GetVcs() string {
	if m != nil {
		return m.Vcs
	}
	return ""
}

func (m *ReviewRequest) GetDotlingo() string {
	if m != nil {
		return m.Dotlingo
	}
	return ""
}

func (m *ReviewRequest) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

// Issue returned from a review.
type Issue struct {
	// The name of the issue.
	Name          string            `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Position      *IssueRange       `protobuf:"bytes,2,opt,name=position" json:"position,omitempty"`
	Comment       string            `protobuf:"bytes,3,opt,name=comment" json:"comment,omitempty"`
	CtxBefore     string            `protobuf:"bytes,4,opt,name=ctxBefore" json:"ctxBefore,omitempty"`
	LineText      string            `protobuf:"bytes,5,opt,name=lineText" json:"lineText,omitempty"`
	CtxAfter      string            `protobuf:"bytes,6,opt,name=ctxAfter" json:"ctxAfter,omitempty"`
	Metrics       map[string]string `protobuf:"bytes,7,rep,name=metrics" json:"metrics,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Tags          []string          `protobuf:"bytes,8,rep,name=tags" json:"tags,omitempty"`
	Link          string            `protobuf:"bytes,9,opt,name=link" json:"link,omitempty"`
	NewCode       bool              `protobuf:"varint,10,opt,name=newCode" json:"newCode,omitempty"`
	Patch         string            `protobuf:"bytes,11,opt,name=patch" json:"patch,omitempty"`
	Err           string            `protobuf:"bytes,12,opt,name=err" json:"err,omitempty"`
	Discard       bool              `protobuf:"varint,13,opt,name=discard" json:"discard,omitempty"`
	DiscardReason string            `protobuf:"bytes,14,opt,name=discardReason" json:"discardReason,omitempty"`
}

func (m *Issue) Reset()                    { *m = Issue{} }
func (m *Issue) String() string            { return proto.CompactTextString(m) }
func (*Issue) ProtoMessage()               {}
func (*Issue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *Issue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Issue) GetPosition() *IssueRange {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Issue) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Issue) GetCtxBefore() string {
	if m != nil {
		return m.CtxBefore
	}
	return ""
}

func (m *Issue) GetLineText() string {
	if m != nil {
		return m.LineText
	}
	return ""
}

func (m *Issue) GetCtxAfter() string {
	if m != nil {
		return m.CtxAfter
	}
	return ""
}

func (m *Issue) GetMetrics() map[string]string {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *Issue) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Issue) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *Issue) GetNewCode() bool {
	if m != nil {
		return m.NewCode
	}
	return false
}

func (m *Issue) GetPatch() string {
	if m != nil {
		return m.Patch
	}
	return ""
}

func (m *Issue) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

func (m *Issue) GetDiscard() bool {
	if m != nil {
		return m.Discard
	}
	return false
}

func (m *Issue) GetDiscardReason() string {
	if m != nil {
		return m.DiscardReason
	}
	return ""
}

type IssueRange struct {
	Start *Position `protobuf:"bytes,1,opt,name=start" json:"start,omitempty"`
	End   *Position `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *IssueRange) Reset()                    { *m = IssueRange{} }
func (m *IssueRange) String() string            { return proto.CompactTextString(m) }
func (*IssueRange) ProtoMessage()               {}
func (*IssueRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *IssueRange) GetStart() *Position {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *IssueRange) GetEnd() *Position {
	if m != nil {
		return m.End
	}
	return nil
}

type Position struct {
	Filename string `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
	Offset   int64  `protobuf:"varint,2,opt,name=Offset" json:"Offset,omitempty"`
	Line     int64  `protobuf:"varint,3,opt,name=Line" json:"Line,omitempty"`
	Column   int64  `protobuf:"varint,4,opt,name=Column" json:"Column,omitempty"`
}

func (m *Position) Reset()                    { *m = Position{} }
func (m *Position) String() string            { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()               {}
func (*Position) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *Position) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *Position) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Position) GetLine() int64 {
	if m != nil {
		return m.Line
	}
	return 0
}

func (m *Position) GetColumn() int64 {
	if m != nil {
		return m.Column
	}
	return 0
}

type LatestClientVersionRequest struct {
}

func (m *LatestClientVersionRequest) Reset()                    { *m = LatestClientVersionRequest{} }
func (m *LatestClientVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*LatestClientVersionRequest) ProtoMessage()               {}
func (*LatestClientVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

type LatestClientVersionReply struct {
	Version string `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
}

func (m *LatestClientVersionReply) Reset()                    { *m = LatestClientVersionReply{} }
func (m *LatestClientVersionReply) String() string            { return proto.CompactTextString(m) }
func (*LatestClientVersionReply) ProtoMessage()               {}
func (*LatestClientVersionReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *LatestClientVersionReply) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func init() {
	proto.RegisterType((*DescribeFactRequest)(nil), "codelingo.DescribeFactRequest")
	proto.RegisterType((*DescribeFactReply)(nil), "codelingo.DescribeFactReply")
	proto.RegisterType((*Property)(nil), "codelingo.Property")
	proto.RegisterType((*PathsFromOffsetRequest)(nil), "codelingo.PathsFromOffsetRequest")
	proto.RegisterType((*PathsFromOffsetReply)(nil), "codelingo.PathsFromOffsetReply")
	proto.RegisterType((*Path)(nil), "codelingo.Path")
	proto.RegisterType((*ListFactsRequest)(nil), "codelingo.ListFactsRequest")
	proto.RegisterType((*FactList)(nil), "codelingo.FactList")
	proto.RegisterType((*Children)(nil), "codelingo.Children")
	proto.RegisterType((*ListLexiconsRequest)(nil), "codelingo.ListLexiconsRequest")
	proto.RegisterType((*ListLexiconsReply)(nil), "codelingo.ListLexiconsReply")
	proto.RegisterType((*SessionRequest)(nil), "codelingo.SessionRequest")
	proto.RegisterType((*SessionReply)(nil), "codelingo.SessionReply")
	proto.RegisterType((*QueryRequest)(nil), "codelingo.QueryRequest")
	proto.RegisterType((*MetaDatum)(nil), "codelingo.MetaDatum")
	proto.RegisterType((*Fact)(nil), "codelingo.Fact")
	proto.RegisterType((*Argument)(nil), "codelingo.Argument")
	proto.RegisterType((*IntComparison)(nil), "codelingo.IntComparison")
	proto.RegisterType((*FloatComparison)(nil), "codelingo.FloatComparison")
	proto.RegisterType((*FactSet)(nil), "codelingo.FactSet")
	proto.RegisterType((*Lexicon)(nil), "codelingo.Lexicon")
	proto.RegisterType((*QueryReply)(nil), "codelingo.QueryReply")
	proto.RegisterType((*QueryReply_DataList)(nil), "codelingo.QueryReply.DataList")
	proto.RegisterType((*ReviewRequest)(nil), "codelingo.ReviewRequest")
	proto.RegisterType((*Issue)(nil), "codelingo.Issue")
	proto.RegisterType((*IssueRange)(nil), "codelingo.IssueRange")
	proto.RegisterType((*Position)(nil), "codelingo.Position")
	proto.RegisterType((*LatestClientVersionRequest)(nil), "codelingo.LatestClientVersionRequest")
	proto.RegisterType((*LatestClientVersionReply)(nil), "codelingo.LatestClientVersionReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CodeLingo service

type CodeLingoClient interface {
	// Initialise session
	Session(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*SessionReply, error)
	// Reviews files
	Review(ctx context.Context, opts ...grpc.CallOption) (CodeLingo_ReviewClient, error)
	// Queries source code
	Query(ctx context.Context, opts ...grpc.CallOption) (CodeLingo_QueryClient, error)
	// Lists available lexicons
	ListLexicons(ctx context.Context, in *ListLexiconsRequest, opts ...grpc.CallOption) (*ListLexiconsReply, error)
	ListFacts(ctx context.Context, in *ListFactsRequest, opts ...grpc.CallOption) (*FactList, error)
	PathsFromOffset(ctx context.Context, in *PathsFromOffsetRequest, opts ...grpc.CallOption) (*PathsFromOffsetReply, error)
	DescribeFact(ctx context.Context, in *DescribeFactRequest, opts ...grpc.CallOption) (*DescribeFactReply, error)
	// Return the latest client version for this platform
	LatestClientVersion(ctx context.Context, in *LatestClientVersionRequest, opts ...grpc.CallOption) (*LatestClientVersionReply, error)
}

type codeLingoClient struct {
	cc *grpc.ClientConn
}

func NewCodeLingoClient(cc *grpc.ClientConn) CodeLingoClient {
	return &codeLingoClient{cc}
}

func (c *codeLingoClient) Session(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*SessionReply, error) {
	out := new(SessionReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/Session", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) Review(ctx context.Context, opts ...grpc.CallOption) (CodeLingo_ReviewClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CodeLingo_serviceDesc.Streams[0], c.cc, "/codelingo.CodeLingo/Review", opts...)
	if err != nil {
		return nil, err
	}
	x := &codeLingoReviewClient{stream}
	return x, nil
}

type CodeLingo_ReviewClient interface {
	Send(*ReviewRequest) error
	Recv() (*Issue, error)
	grpc.ClientStream
}

type codeLingoReviewClient struct {
	grpc.ClientStream
}

func (x *codeLingoReviewClient) Send(m *ReviewRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *codeLingoReviewClient) Recv() (*Issue, error) {
	m := new(Issue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *codeLingoClient) Query(ctx context.Context, opts ...grpc.CallOption) (CodeLingo_QueryClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CodeLingo_serviceDesc.Streams[1], c.cc, "/codelingo.CodeLingo/Query", opts...)
	if err != nil {
		return nil, err
	}
	x := &codeLingoQueryClient{stream}
	return x, nil
}

type CodeLingo_QueryClient interface {
	Send(*QueryRequest) error
	Recv() (*QueryReply, error)
	grpc.ClientStream
}

type codeLingoQueryClient struct {
	grpc.ClientStream
}

func (x *codeLingoQueryClient) Send(m *QueryRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *codeLingoQueryClient) Recv() (*QueryReply, error) {
	m := new(QueryReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *codeLingoClient) ListLexicons(ctx context.Context, in *ListLexiconsRequest, opts ...grpc.CallOption) (*ListLexiconsReply, error) {
	out := new(ListLexiconsReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/ListLexicons", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) ListFacts(ctx context.Context, in *ListFactsRequest, opts ...grpc.CallOption) (*FactList, error) {
	out := new(FactList)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/ListFacts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) PathsFromOffset(ctx context.Context, in *PathsFromOffsetRequest, opts ...grpc.CallOption) (*PathsFromOffsetReply, error) {
	out := new(PathsFromOffsetReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/PathsFromOffset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) DescribeFact(ctx context.Context, in *DescribeFactRequest, opts ...grpc.CallOption) (*DescribeFactReply, error) {
	out := new(DescribeFactReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/DescribeFact", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) LatestClientVersion(ctx context.Context, in *LatestClientVersionRequest, opts ...grpc.CallOption) (*LatestClientVersionReply, error) {
	out := new(LatestClientVersionReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/LatestClientVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CodeLingo service

type CodeLingoServer interface {
	// Initialise session
	Session(context.Context, *SessionRequest) (*SessionReply, error)
	// Reviews files
	Review(CodeLingo_ReviewServer) error
	// Queries source code
	Query(CodeLingo_QueryServer) error
	// Lists available lexicons
	ListLexicons(context.Context, *ListLexiconsRequest) (*ListLexiconsReply, error)
	ListFacts(context.Context, *ListFactsRequest) (*FactList, error)
	PathsFromOffset(context.Context, *PathsFromOffsetRequest) (*PathsFromOffsetReply, error)
	DescribeFact(context.Context, *DescribeFactRequest) (*DescribeFactReply, error)
	// Return the latest client version for this platform
	LatestClientVersion(context.Context, *LatestClientVersionRequest) (*LatestClientVersionReply, error)
}

func RegisterCodeLingoServer(s *grpc.Server, srv CodeLingoServer) {
	s.RegisterService(&_CodeLingo_serviceDesc, srv)
}

func _CodeLingo_Session_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).Session(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/Session",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).Session(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_Review_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CodeLingoServer).Review(&codeLingoReviewServer{stream})
}

type CodeLingo_ReviewServer interface {
	Send(*Issue) error
	Recv() (*ReviewRequest, error)
	grpc.ServerStream
}

type codeLingoReviewServer struct {
	grpc.ServerStream
}

func (x *codeLingoReviewServer) Send(m *Issue) error {
	return x.ServerStream.SendMsg(m)
}

func (x *codeLingoReviewServer) Recv() (*ReviewRequest, error) {
	m := new(ReviewRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CodeLingo_Query_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CodeLingoServer).Query(&codeLingoQueryServer{stream})
}

type CodeLingo_QueryServer interface {
	Send(*QueryReply) error
	Recv() (*QueryRequest, error)
	grpc.ServerStream
}

type codeLingoQueryServer struct {
	grpc.ServerStream
}

func (x *codeLingoQueryServer) Send(m *QueryReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *codeLingoQueryServer) Recv() (*QueryRequest, error) {
	m := new(QueryRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CodeLingo_ListLexicons_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLexiconsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).ListLexicons(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/ListLexicons",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).ListLexicons(ctx, req.(*ListLexiconsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_ListFacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).ListFacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/ListFacts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).ListFacts(ctx, req.(*ListFactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_PathsFromOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathsFromOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).PathsFromOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/PathsFromOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).PathsFromOffset(ctx, req.(*PathsFromOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_DescribeFact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeFactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).DescribeFact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/DescribeFact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).DescribeFact(ctx, req.(*DescribeFactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_LatestClientVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestClientVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).LatestClientVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/LatestClientVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).LatestClientVersion(ctx, req.(*LatestClientVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CodeLingo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "codelingo.CodeLingo",
	HandlerType: (*CodeLingoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Session",
			Handler:    _CodeLingo_Session_Handler,
		},
		{
			MethodName: "ListLexicons",
			Handler:    _CodeLingo_ListLexicons_Handler,
		},
		{
			MethodName: "ListFacts",
			Handler:    _CodeLingo_ListFacts_Handler,
		},
		{
			MethodName: "PathsFromOffset",
			Handler:    _CodeLingo_PathsFromOffset_Handler,
		},
		{
			MethodName: "DescribeFact",
			Handler:    _CodeLingo_DescribeFact_Handler,
		},
		{
			MethodName: "LatestClientVersion",
			Handler:    _CodeLingo_LatestClientVersion_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Review",
			Handler:       _CodeLingo_Review_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Query",
			Handler:       _CodeLingo_Query_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "codelingo.proto",
}

func init() { proto.RegisterFile("codelingo.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1594 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x58, 0xef, 0x6e, 0xdc, 0x44,
	0x10, 0x3f, 0x9f, 0xef, 0x72, 0xbe, 0xc9, 0xdf, 0x6e, 0xd2, 0xd6, 0x98, 0x90, 0x06, 0x97, 0x48,
	0x01, 0xa4, 0x03, 0xda, 0x0a, 0x50, 0xa5, 0xaa, 0xe4, 0x4f, 0x4b, 0x22, 0xa5, 0x21, 0x75, 0xab,
	0x16, 0x84, 0x84, 0xb4, 0xb5, 0x37, 0x17, 0x53, 0x9f, 0x6d, 0xd6, 0x7b, 0x69, 0xf2, 0x91, 0x2f,
	0x7c, 0x45, 0x42, 0xbc, 0x00, 0xbc, 0x04, 0x0f, 0xc0, 0x73, 0xf0, 0x95, 0xe7, 0x40, 0xb3, 0xbb,
	0xf6, 0xad, 0xef, 0x4f, 0x8b, 0x10, 0x9f, 0x6e, 0x66, 0x76, 0x76, 0x76, 0x66, 0x76, 0xe6, 0xe7,
	0xd9, 0x83, 0xe5, 0x30, 0x8b, 0x58, 0x12, 0xa7, 0xfd, 0xac, 0x97, 0xf3, 0x4c, 0x64, 0xa4, 0x5b,
	0x09, 0xfc, 0x01, 0xac, 0xee, 0xb3, 0x22, 0xe4, 0xf1, 0x0b, 0xf6, 0x90, 0x86, 0x22, 0x60, 0x3f,
	0x0c, 0x59, 0x21, 0xc8, 0x1a, 0xb4, 0xb3, 0x57, 0x29, 0xe3, 0xae, 0xb5, 0x69, 0x6d, 0x77, 0x03,
	0xc5, 0x10, 0x02, 0xad, 0x94, 0x0e, 0x98, 0xdb, 0x94, 0x42, 0x49, 0x13, 0x17, 0x3a, 0xe7, 0x8c,
	0x17, 0x71, 0x96, 0xba, 0xb6, 0x14, 0x97, 0x2c, 0x6a, 0x9f, 0xd2, 0x50, 0xb8, 0x2d, 0xa5, 0x8d,
	0xb4, 0xff, 0x93, 0x05, 0x57, 0xea, 0xe7, 0xe5, 0xc9, 0x25, 0xd9, 0x84, 0xf9, 0x48, 0x0a, 0x73,
	0x81, 0x76, 0xd4, 0x99, 0xa6, 0x88, 0x78, 0xe0, 0xb0, 0x0b, 0x3a, 0xc8, 0x13, 0x56, 0xe8, 0xd3,
	0x2b, 0x9e, 0xdc, 0x06, 0xc8, 0x79, 0x96, 0x33, 0x2e, 0x62, 0x56, 0xb8, 0xf6, 0xa6, 0xbd, 0x3d,
	0x7f, 0x6b, 0xb5, 0x37, 0x8a, 0xf9, 0x44, 0x2d, 0x5e, 0x06, 0x86, 0x9a, 0xff, 0x05, 0x38, 0xa5,
	0xbc, 0x0a, 0xcb, 0x32, 0xc2, 0x1a, 0x73, 0xa9, 0x39, 0xe1, 0x92, 0xff, 0xab, 0x05, 0xd7, 0x4e,
	0xa8, 0x38, 0x2b, 0x1e, 0xf2, 0x6c, 0xf0, 0xd5, 0xe9, 0x69, 0xc1, 0xaa, 0xec, 0x11, 0x68, 0x25,
	0x34, 0xed, 0x97, 0x06, 0x91, 0x26, 0x2b, 0x60, 0x47, 0x31, 0xd7, 0x86, 0x90, 0xc4, 0x98, 0x4e,
	0xe3, 0x84, 0xc9, 0xa3, 0x55, 0xea, 0x2a, 0x1e, 0xb5, 0x0b, 0x1e, 0xea, 0xd4, 0x21, 0x89, 0x37,
	0x52, 0x08, 0xca, 0x85, 0xdb, 0xde, 0xb4, 0xb6, 0xed, 0x40, 0x31, 0xa8, 0xc7, 0xd2, 0xc8, 0x9d,
	0x93, 0x32, 0x24, 0xfd, 0x7b, 0xb0, 0x36, 0xe1, 0x15, 0xe6, 0x78, 0x0b, 0xda, 0x39, 0xca, 0x5d,
	0x4b, 0x26, 0x68, 0xd9, 0x4c, 0x10, 0x15, 0x67, 0x81, 0x5a, 0xf5, 0xd7, 0xa1, 0x85, 0x2c, 0x1e,
	0x97, 0x66, 0x11, 0x53, 0xea, 0xdd, 0x40, 0x31, 0xfe, 0x33, 0x58, 0x39, 0x8a, 0x0b, 0x81, 0x37,
	0x57, 0xfc, 0x8f, 0xa5, 0xe2, 0xff, 0x6c, 0x81, 0x83, 0x46, 0xd1, 0x38, 0xb9, 0x03, 0x6d, 0xac,
	0x95, 0xd2, 0xd3, 0x0d, 0xc3, 0xd3, 0x52, 0x47, 0x12, 0xc5, 0x83, 0x54, 0xf0, 0xcb, 0x40, 0x29,
	0x7b, 0x8f, 0x00, 0x46, 0x42, 0xcc, 0xcb, 0x4b, 0x76, 0xa9, 0x5d, 0x42, 0x92, 0xbc, 0x0f, 0xed,
	0x73, 0x9a, 0x0c, 0x95, 0x47, 0xf5, 0x02, 0xd9, 0x3b, 0x8b, 0x93, 0x88, 0xb3, 0x34, 0x50, 0x1a,
	0x77, 0x9b, 0x9f, 0x5b, 0xfe, 0x26, 0x38, 0xa5, 0x18, 0x23, 0x0c, 0x91, 0x2e, 0x73, 0x21, 0x19,
	0xff, 0x2a, 0xac, 0xa2, 0x2b, 0x47, 0xec, 0x22, 0x0e, 0xb3, 0xb4, 0x4c, 0x87, 0xff, 0x11, 0x5c,
	0xa9, 0x8b, 0x31, 0xf9, 0x1e, 0x38, 0x89, 0x16, 0x68, 0x23, 0x15, 0xef, 0xaf, 0xc0, 0xd2, 0x13,
	0x56, 0x60, 0x1a, 0x4a, 0x13, 0x9b, 0xb0, 0x50, 0x49, 0x70, 0xf7, 0x44, 0x30, 0xfe, 0x8f, 0x4d,
	0x58, 0x78, 0x3c, 0x64, 0xfc, 0xb2, 0xbc, 0x84, 0x0f, 0xc1, 0xc1, 0x34, 0x3c, 0xe5, 0x4c, 0x95,
	0x71, 0xfd, 0x82, 0x65, 0xa7, 0x55, 0x0a, 0xa4, 0x67, 0x78, 0xd3, 0x94, 0x39, 0x26, 0x86, 0xb2,
	0xf6, 0x7c, 0xe4, 0x21, 0xd9, 0x01, 0x67, 0xc0, 0x04, 0x8d, 0xa8, 0xa0, 0xba, 0xbd, 0xb6, 0x0c,
	0x7d, 0xd3, 0x8f, 0xde, 0x23, 0xad, 0xa7, 0xae, 0xa6, 0xda, 0xe6, 0x3d, 0x86, 0xc5, 0xda, 0xd2,
	0x94, 0x0b, 0xfa, 0xa0, 0x7e, 0x41, 0x6b, 0xc6, 0x11, 0xb8, 0x75, 0x9f, 0x8a, 0xe1, 0xc0, 0xbc,
	0xa1, 0xaf, 0xa1, 0x5b, 0xc9, 0x89, 0x0b, 0x73, 0x85, 0xe0, 0x71, 0xd9, 0x73, 0x07, 0x8d, 0x40,
	0xf3, 0x84, 0x80, 0x1d, 0xa7, 0x42, 0x1a, 0xb5, 0x0f, 0x1a, 0x01, 0x32, 0x64, 0x0d, 0x5a, 0x2f,
	0xb2, 0x2c, 0x91, 0x55, 0xe8, 0x1c, 0x34, 0x02, 0xc9, 0xed, 0x76, 0xa0, 0x1d, 0xa1, 0x31, 0xff,
	0x4f, 0x0b, 0x5a, 0x98, 0x32, 0xb2, 0x0e, 0xdd, 0x63, 0x3a, 0x60, 0x45, 0x4e, 0xc3, 0x12, 0x1d,
	0x46, 0x02, 0x2c, 0xf1, 0x63, 0xa3, 0xc4, 0x91, 0xc6, 0x1d, 0x3a, 0x7f, 0x87, 0xfb, 0xba, 0xc8,
	0x47, 0x02, 0x6c, 0x80, 0x63, 0xd6, 0xa7, 0x82, 0x45, 0xb2, 0xb3, 0x9d, 0xa0, 0x64, 0xb1, 0xc4,
	0xf6, 0x59, 0x2e, 0xce, 0xca, 0xee, 0x96, 0x0c, 0x4a, 0xbf, 0x89, 0x59, 0xa2, 0xfa, 0xdb, 0x09,
	0x14, 0x43, 0xb6, 0xc0, 0xde, 0xe1, 0x7d, 0xb7, 0x33, 0x51, 0xc7, 0x3b, 0xbc, 0x3f, 0x1c, 0xb0,
	0x54, 0x04, 0xb8, 0xee, 0xff, 0xd1, 0x04, 0xa7, 0x94, 0x90, 0x0d, 0xe8, 0xaa, 0x7c, 0x50, 0x3e,
	0x4a, 0xd1, 0x48, 0x44, 0xd6, 0xc1, 0xe1, 0xac, 0xcf, 0x2e, 0x70, 0xb9, 0xa9, 0x97, 0x2b, 0x09,
	0x66, 0xf7, 0x9c, 0x72, 0x5c, 0xb3, 0xcb, 0xec, 0x2a, 0x9e, 0x3c, 0x84, 0x95, 0xc3, 0x54, 0x84,
	0xd9, 0x20, 0xa7, 0x3c, 0x2e, 0xb2, 0x14, 0x75, 0x5a, 0xd2, 0x31, 0xd7, 0x70, 0xec, 0x30, 0x15,
	0x7b, 0x95, 0xca, 0x41, 0x23, 0x98, 0xd8, 0x43, 0x8e, 0x80, 0x9c, 0x26, 0x19, 0x1d, 0xb3, 0xd4,
	0x96, 0x96, 0x3c, 0xb3, 0x92, 0x51, 0xa9, 0x66, 0x6b, 0xca, 0x3e, 0xf2, 0x29, 0xcc, 0x63, 0xb1,
	0x27, 0x31, 0x82, 0x64, 0x5f, 0x66, 0xaf, 0x5e, 0xe3, 0x78, 0xbb, 0x4f, 0x98, 0x38, 0x68, 0x04,
	0xa6, 0xe2, 0x6e, 0x1b, 0x6c, 0xca, 0xfb, 0xfe, 0x03, 0x58, 0xac, 0x79, 0x8c, 0xf7, 0xa0, 0x4a,
	0xd3, 0x52, 0xb7, 0x23, 0x19, 0xb2, 0x01, 0x30, 0x3a, 0x56, 0x57, 0x81, 0x21, 0xf1, 0xbf, 0x84,
	0xe5, 0x31, 0x77, 0xeb, 0x86, 0x9a, 0xff, 0xd6, 0x50, 0x0f, 0x3a, 0xda, 0x61, 0x72, 0x13, 0x5a,
	0xe8, 0xec, 0x14, 0x10, 0x97, 0x3d, 0x2e, 0x17, 0xfd, 0x47, 0xd0, 0xd1, 0x35, 0x67, 0x42, 0xae,
	0x55, 0xff, 0x3a, 0x57, 0xb0, 0xdd, 0x9c, 0x06, 0xdb, 0xf6, 0x08, 0xb6, 0xfd, 0x5f, 0x6c, 0x00,
	0xdd, 0xe4, 0x88, 0x46, 0x4b, 0xd0, 0x8c, 0x23, 0x6d, 0xad, 0x19, 0x47, 0xb8, 0xe5, 0x65, 0x9c,
	0x46, 0x12, 0x49, 0xba, 0x81, 0xa4, 0xc9, 0x6d, 0x68, 0x19, 0x68, 0x71, 0x63, 0x12, 0x2d, 0xf2,
	0xe4, 0xb2, 0xb7, 0x5f, 0xe1, 0x84, 0x54, 0x26, 0xf7, 0x0d, 0x98, 0x69, 0xc9, 0x8d, 0x37, 0xa7,
	0x6f, 0x9c, 0x01, 0x32, 0x18, 0x12, 0xe3, 0x3c, 0xe3, 0xb2, 0x6e, 0xba, 0x81, 0x62, 0xbc, 0x0d,
	0x70, 0xf0, 0x24, 0xf9, 0x69, 0x21, 0xda, 0x2f, 0x85, 0xc1, 0x92, 0xf6, 0x9e, 0x43, 0x77, 0xff,
	0x35, 0xb0, 0x74, 0xa7, 0x0e, 0x4b, 0x1b, 0xb3, 0x63, 0xc1, 0x13, 0x0c, 0x80, 0xf2, 0xbe, 0x7d,
	0x33, 0xe6, 0xfd, 0x67, 0xe3, 0xfe, 0x6f, 0x4d, 0x58, 0x0c, 0xd8, 0x79, 0xcc, 0x5e, 0x19, 0x43,
	0xc7, 0x59, 0x26, 0x4b, 0x43, 0x5e, 0x1d, 0xd2, 0xf8, 0xdd, 0xc1, 0x5f, 0xe3, 0x4b, 0x5c, 0xf1,
	0xa3, 0x02, 0xb0, 0xc7, 0x0a, 0x80, 0xb3, 0x3c, 0x2b, 0x87, 0x36, 0xa4, 0xe5, 0x30, 0x72, 0x46,
	0x75, 0x56, 0x91, 0xc4, 0xb2, 0x3a, 0xa1, 0x22, 0x3c, 0x63, 0x85, 0x3b, 0x27, 0x53, 0x59, 0xb2,
	0xe4, 0x3d, 0x58, 0x8c, 0x8b, 0x93, 0x61, 0x92, 0x68, 0xb7, 0x24, 0x4c, 0x39, 0x41, 0x5d, 0x88,
	0x5a, 0xf9, 0x88, 0x3d, 0xdc, 0x77, 0x1d, 0xd9, 0x58, 0x75, 0x21, 0x9e, 0x7b, 0x1e, 0x16, 0x6e,
	0x57, 0x9d, 0x7b, 0x1e, 0x16, 0x18, 0x4f, 0x94, 0x09, 0x99, 0x20, 0x17, 0x54, 0x3c, 0x25, 0x5f,
	0x0e, 0x58, 0xf3, 0xd5, 0x80, 0xe5, 0xff, 0x65, 0x43, 0xfb, 0xb0, 0x28, 0x86, 0x6c, 0xea, 0x84,
	0xf7, 0x09, 0x38, 0x79, 0x56, 0xc4, 0xd5, 0x78, 0x37, 0x7f, 0xeb, 0xaa, 0x09, 0x59, 0xb8, 0x2f,
	0xa0, 0x69, 0x9f, 0x05, 0x95, 0x1a, 0x86, 0x1d, 0x66, 0x03, 0x04, 0xd4, 0x72, 0x80, 0xd1, 0x2c,
	0xe2, 0x7e, 0x28, 0x2e, 0x76, 0xd9, 0x69, 0xc6, 0x99, 0xce, 0xdd, 0x48, 0x20, 0x3f, 0xff, 0x71,
	0xca, 0x9e, 0xb2, 0x0b, 0xa1, 0xb3, 0x58, 0xf1, 0xb8, 0x16, 0x8a, 0x8b, 0x9d, 0x53, 0xc1, 0xb8,
	0x04, 0xaa, 0x6e, 0x50, 0xf1, 0xe4, 0x33, 0xe8, 0x0c, 0x98, 0xe0, 0x71, 0x58, 0xb8, 0x1d, 0xd9,
	0x10, 0xef, 0x8c, 0x7b, 0x88, 0xbd, 0x80, 0xeb, 0xaa, 0x15, 0x4a, 0x6d, 0x8c, 0x57, 0xd0, 0x7e,
	0xe1, 0x3a, 0xaa, 0xce, 0x91, 0x96, 0x43, 0x69, 0x9c, 0xbe, 0xd4, 0xe9, 0x94, 0x34, 0x06, 0x94,
	0xb2, 0x57, 0x7b, 0x59, 0xc4, 0x64, 0x3a, 0x9d, 0xa0, 0x64, 0xb1, 0x3a, 0x72, 0xbc, 0x52, 0x9d,
	0x4f, 0xc5, 0xc8, 0x71, 0x93, 0x73, 0x77, 0x41, 0xe5, 0x98, 0x71, 0x8e, 0x16, 0xa2, 0xb8, 0x08,
	0x29, 0x8f, 0xdc, 0x45, 0x65, 0x41, 0xb3, 0x78, 0xc7, 0x9a, 0x0c, 0x18, 0x45, 0x60, 0x5b, 0x92,
	0xbb, 0xea, 0x42, 0xef, 0x2e, 0x2c, 0x98, 0x21, 0x4c, 0xe9, 0x91, 0x35, 0xb3, 0x47, 0xba, 0x66,
	0x0f, 0x7c, 0x07, 0x30, 0xba, 0x26, 0x1c, 0xf0, 0xd4, 0x80, 0x6c, 0x4d, 0x7c, 0x18, 0x4f, 0xf4,
	0x05, 0x96, 0x53, 0xf3, 0x96, 0x9a, 0x9a, 0x9b, 0xb3, 0x15, 0xe5, 0x28, 0xfd, 0x3d, 0x38, 0xa5,
	0xa0, 0x36, 0xac, 0x5b, 0x63, 0xc3, 0xfa, 0x35, 0x98, 0x53, 0x93, 0xb6, 0x9a, 0x32, 0x02, 0xcd,
	0x61, 0xc6, 0x8f, 0xe2, 0x54, 0x81, 0xa9, 0x1d, 0x48, 0x1a, 0x75, 0xf7, 0xb2, 0x64, 0x38, 0x48,
	0x65, 0x95, 0xd8, 0x81, 0xe6, 0xfc, 0x75, 0xf0, 0x8e, 0xa8, 0x60, 0x85, 0xd8, 0x4b, 0x62, 0x96,
	0x8a, 0x67, 0x0a, 0xa5, 0xcb, 0x89, 0xf0, 0x0e, 0xb8, 0x53, 0x57, 0x11, 0x8f, 0x67, 0x42, 0xfc,
	0xad, 0xbf, 0x5b, 0xd0, 0xc5, 0xcb, 0x3c, 0x92, 0xfd, 0x71, 0x1f, 0x3a, 0x7a, 0xaa, 0x24, 0x6f,
	0x19, 0x21, 0xd7, 0x67, 0x4f, 0xef, 0xfa, 0xb4, 0xa5, 0x3c, 0xb9, 0xf4, 0x1b, 0xe4, 0x2e, 0xcc,
	0x29, 0xc4, 0x21, 0xe6, 0xb7, 0xbd, 0x06, 0x42, 0xde, 0xca, 0x78, 0x81, 0xfa, 0x8d, 0x6d, 0xeb,
	0x63, 0x8b, 0xdc, 0x83, 0xb6, 0x04, 0x34, 0x72, 0x7d, 0xc6, 0xe4, 0xe8, 0x5d, 0x9d, 0x8a, 0x7d,
	0x7a, 0xfb, 0x31, 0x2c, 0x98, 0x43, 0x35, 0x31, 0x81, 0x72, 0xca, 0x10, 0xee, 0xad, 0xcf, 0x5c,
	0x57, 0xa1, 0xdc, 0x87, 0x6e, 0xf5, 0x8e, 0x21, 0x6f, 0x8f, 0x29, 0x9b, 0xaf, 0x1b, 0x6f, 0x75,
	0xca, 0xeb, 0xc3, 0x6f, 0x90, 0xe7, 0xb0, 0x3c, 0xf6, 0xca, 0x22, 0xef, 0x8e, 0xbd, 0xa8, 0x26,
	0xdf, 0x85, 0xde, 0x8d, 0xd7, 0xa9, 0x28, 0xcf, 0x8e, 0x61, 0xc1, 0x7c, 0x1f, 0xd7, 0x22, 0x9d,
	0xf2, 0x50, 0xaf, 0x45, 0x3a, 0xf1, 0xb0, 0xf6, 0x1b, 0x24, 0x84, 0xd5, 0x29, 0x95, 0x43, 0xcc,
	0x01, 0x7e, 0x76, 0xdd, 0x79, 0x37, 0xdf, 0xa4, 0x26, 0x0f, 0xd9, 0xed, 0xc1, 0x5a, 0x9c, 0x19,
	0xaa, 0x7d, 0x9e, 0x87, 0xbd, 0x30, 0xd9, 0x5d, 0xaa, 0xaa, 0xef, 0x84, 0x67, 0x22, 0x3b, 0xb1,
	0x7e, 0x6f, 0xda, 0x7b, 0x47, 0xcf, 0x5f, 0xcc, 0xc9, 0xbf, 0x21, 0x6e, 0xff, 0x13, 0x00, 0x00,
	0xff, 0xff, 0x93, 0x1d, 0x67, 0x52, 0x99, 0x10, 0x00, 0x00,
}

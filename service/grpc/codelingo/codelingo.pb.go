// Code generated by protoc-gen-go.
// source: codelingo.proto
// DO NOT EDIT!

/*
Package codelingo is a generated protocol buffer package.

It is generated from these files:
	codelingo.proto

It has these top-level messages:
	QueryRequest
	QueryReply
	ReviewRequest
	ReviewReply
	Issue
	IssueRange
	Position
*/
package codelingo

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The request message containing the CLQL source code.
type QueryRequest struct {
	Clql string `protobuf:"bytes,1,opt,name=clql" json:"clql,omitempty"`
}

func (m *QueryRequest) Reset()         { *m = QueryRequest{} }
func (m *QueryRequest) String() string { return proto.CompactTextString(m) }
func (*QueryRequest) ProtoMessage()    {}

// The query response.
type QueryReply struct {
	Result string `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *QueryReply) Reset()         { *m = QueryReply{} }
func (m *QueryReply) String() string { return proto.CompactTextString(m) }
func (*QueryReply) ProtoMessage()    {}

// The request message containing the files or directories to review.
type ReviewRequest struct {
	Owner        string   `protobuf:"bytes,1,opt,name=owner" json:"owner,omitempty"`
	Repo         string   `protobuf:"bytes,2,opt,name=repo" json:"repo,omitempty"`
	Sha          string   `protobuf:"bytes,3,opt,name=sha" json:"sha,omitempty"`
	FilesAndDirs []string `protobuf:"bytes,4,rep,name=filesAndDirs" json:"filesAndDirs,omitempty"`
	Recursive    bool     `protobuf:"varint,5,opt,name=recursive" json:"recursive,omitempty"`
	Patches      []string `protobuf:"bytes,6,rep,name=Patches" json:"Patches,omitempty"`
}

func (m *ReviewRequest) Reset()         { *m = ReviewRequest{} }
func (m *ReviewRequest) String() string { return proto.CompactTextString(m) }
func (*ReviewRequest) ProtoMessage()    {}

type ReviewReply struct {
	Issues []*Issue `protobuf:"bytes,1,rep,name=issues" json:"issues,omitempty"`
}

func (m *ReviewReply) Reset()         { *m = ReviewReply{} }
func (m *ReviewReply) String() string { return proto.CompactTextString(m) }
func (*ReviewReply) ProtoMessage()    {}

func (m *ReviewReply) GetIssues() []*Issue {
	if m != nil {
		return m.Issues
	}
	return nil
}

// Issue returned from a review.
type Issue struct {
	// The name of the issue.
	Name          string            `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Position      *IssueRange       `protobuf:"bytes,2,opt,name=position" json:"position,omitempty"`
	Comment       string            `protobuf:"bytes,3,opt,name=comment" json:"comment,omitempty"`
	CtxBefore     string            `protobuf:"bytes,4,opt,name=ctxBefore" json:"ctxBefore,omitempty"`
	LineText      string            `protobuf:"bytes,5,opt,name=lineText" json:"lineText,omitempty"`
	CtxAfter      string            `protobuf:"bytes,6,opt,name=ctxAfter" json:"ctxAfter,omitempty"`
	Metrics       map[string]string `protobuf:"bytes,7,rep,name=metrics" json:"metrics,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Tags          []string          `protobuf:"bytes,8,rep,name=tags" json:"tags,omitempty"`
	Link          string            `protobuf:"bytes,9,opt,name=link" json:"link,omitempty"`
	NewCode       bool              `protobuf:"varint,10,opt,name=newCode" json:"newCode,omitempty"`
	Patch         string            `protobuf:"bytes,11,opt,name=patch" json:"patch,omitempty"`
	Err           string            `protobuf:"bytes,12,opt,name=err" json:"err,omitempty"`
	Discard       bool              `protobuf:"varint,13,opt,name=discard" json:"discard,omitempty"`
	DiscardReason string            `protobuf:"bytes,14,opt,name=discardReason" json:"discardReason,omitempty"`
}

func (m *Issue) Reset()         { *m = Issue{} }
func (m *Issue) String() string { return proto.CompactTextString(m) }
func (*Issue) ProtoMessage()    {}

func (m *Issue) GetPosition() *IssueRange {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Issue) GetMetrics() map[string]string {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type IssueRange struct {
	Start *Position `protobuf:"bytes,1,opt,name=start" json:"start,omitempty"`
	End   *Position `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *IssueRange) Reset()         { *m = IssueRange{} }
func (m *IssueRange) String() string { return proto.CompactTextString(m) }
func (*IssueRange) ProtoMessage()    {}

func (m *IssueRange) GetStart() *Position {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *IssueRange) GetEnd() *Position {
	if m != nil {
		return m.End
	}
	return nil
}

type Position struct {
	Filename string `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
	Offset   int64  `protobuf:"varint,2,opt,name=Offset" json:"Offset,omitempty"`
	Line     int64  `protobuf:"varint,3,opt,name=Line" json:"Line,omitempty"`
	Column   int64  `protobuf:"varint,4,opt,name=Column" json:"Column,omitempty"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}

func init() {
	proto.RegisterType((*QueryRequest)(nil), "codelingo.QueryRequest")
	proto.RegisterType((*QueryReply)(nil), "codelingo.QueryReply")
	proto.RegisterType((*ReviewRequest)(nil), "codelingo.ReviewRequest")
	proto.RegisterType((*ReviewReply)(nil), "codelingo.ReviewReply")
	proto.RegisterType((*Issue)(nil), "codelingo.Issue")
	proto.RegisterType((*IssueRange)(nil), "codelingo.IssueRange")
	proto.RegisterType((*Position)(nil), "codelingo.Position")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for CodeLingo service

type CodeLingoClient interface {
	Review(ctx context.Context, in *ReviewRequest, opts ...grpc.CallOption) (*ReviewReply, error)
	// Queries source code
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryReply, error)
}

type codeLingoClient struct {
	cc *grpc.ClientConn
}

func NewCodeLingoClient(cc *grpc.ClientConn) CodeLingoClient {
	return &codeLingoClient{cc}
}

func (c *codeLingoClient) Review(ctx context.Context, in *ReviewRequest, opts ...grpc.CallOption) (*ReviewReply, error) {
	out := new(ReviewReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/Review", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryReply, error) {
	out := new(QueryReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CodeLingo service

type CodeLingoServer interface {
	Review(context.Context, *ReviewRequest) (*ReviewReply, error)
	// Queries source code
	Query(context.Context, *QueryRequest) (*QueryReply, error)
}

func RegisterCodeLingoServer(s *grpc.Server, srv CodeLingoServer) {
	s.RegisterService(&_CodeLingo_serviceDesc, srv)
}

func _CodeLingo_Review_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReviewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(CodeLingoServer).Review(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _CodeLingo_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(CodeLingoServer).Query(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _CodeLingo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "codelingo.CodeLingo",
	HandlerType: (*CodeLingoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Review",
			Handler:    _CodeLingo_Review_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _CodeLingo_Query_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

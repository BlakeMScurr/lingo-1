// Code generated by protoc-gen-go.
// source: codelingo.proto
// DO NOT EDIT!

/*
Package codelingo is a generated protocol buffer package.

It is generated from these files:
	codelingo.proto

It has these top-level messages:
	DescribeFactRequest
	DescribeFactReply
	Property
	PathsFromOffsetRequest
	PathsFromOffsetReply
	Path
	ListFactsRequest
	FactList
	Children
	ListLexiconsRequest
	ListLexiconsReply
	SessionRequest
	SessionReply
	QueryRequest
	QueryReply
	ReviewRequest
	ReviewReply
	Issue
	IssueRange
	Position
*/
package codelingo

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DescribeFactRequest struct {
	Owner   string `protobuf:"bytes,1,opt,name=owner" json:"owner,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
	Fact    string `protobuf:"bytes,4,opt,name=fact" json:"fact,omitempty"`
}

func (m *DescribeFactRequest) Reset()                    { *m = DescribeFactRequest{} }
func (m *DescribeFactRequest) String() string            { return proto.CompactTextString(m) }
func (*DescribeFactRequest) ProtoMessage()               {}
func (*DescribeFactRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DescribeFactRequest) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *DescribeFactRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DescribeFactRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *DescribeFactRequest) GetFact() string {
	if m != nil {
		return m.Fact
	}
	return ""
}

type DescribeFactReply struct {
	Description string      `protobuf:"bytes,1,opt,name=description" json:"description,omitempty"`
	Examples    string      `protobuf:"bytes,2,opt,name=examples" json:"examples,omitempty"`
	Properties  []*Property `protobuf:"bytes,3,rep,name=properties" json:"properties,omitempty"`
}

func (m *DescribeFactReply) Reset()                    { *m = DescribeFactReply{} }
func (m *DescribeFactReply) String() string            { return proto.CompactTextString(m) }
func (*DescribeFactReply) ProtoMessage()               {}
func (*DescribeFactReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DescribeFactReply) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DescribeFactReply) GetExamples() string {
	if m != nil {
		return m.Examples
	}
	return ""
}

func (m *DescribeFactReply) GetProperties() []*Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

type Property struct {
	Name        string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
}

func (m *Property) Reset()                    { *m = Property{} }
func (m *Property) String() string            { return proto.CompactTextString(m) }
func (*Property) ProtoMessage()               {}
func (*Property) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Property) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Property) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type PathsFromOffsetRequest struct {
	Lang     string `protobuf:"bytes,1,opt,name=lang" json:"lang,omitempty"`
	Dir      string `protobuf:"bytes,2,opt,name=dir" json:"dir,omitempty"`
	Filename string `protobuf:"bytes,3,opt,name=filename" json:"filename,omitempty"`
	Src      string `protobuf:"bytes,4,opt,name=src" json:"src,omitempty"`
	Start    int64  `protobuf:"varint,5,opt,name=start" json:"start,omitempty"`
	End      int64  `protobuf:"varint,6,opt,name=end" json:"end,omitempty"`
}

func (m *PathsFromOffsetRequest) Reset()                    { *m = PathsFromOffsetRequest{} }
func (m *PathsFromOffsetRequest) String() string            { return proto.CompactTextString(m) }
func (*PathsFromOffsetRequest) ProtoMessage()               {}
func (*PathsFromOffsetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *PathsFromOffsetRequest) GetLang() string {
	if m != nil {
		return m.Lang
	}
	return ""
}

func (m *PathsFromOffsetRequest) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *PathsFromOffsetRequest) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *PathsFromOffsetRequest) GetSrc() string {
	if m != nil {
		return m.Src
	}
	return ""
}

func (m *PathsFromOffsetRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *PathsFromOffsetRequest) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

type PathsFromOffsetReply struct {
	Paths []*Path `protobuf:"bytes,1,rep,name=paths" json:"paths,omitempty"`
}

func (m *PathsFromOffsetReply) Reset()                    { *m = PathsFromOffsetReply{} }
func (m *PathsFromOffsetReply) String() string            { return proto.CompactTextString(m) }
func (*PathsFromOffsetReply) ProtoMessage()               {}
func (*PathsFromOffsetReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PathsFromOffsetReply) GetPaths() []*Path {
	if m != nil {
		return m.Paths
	}
	return nil
}

type Path struct {
	Nodes []string `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Path) GetNodes() []string {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type ListFactsRequest struct {
	Owner   string `protobuf:"bytes,1,opt,name=owner" json:"owner,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
}

func (m *ListFactsRequest) Reset()                    { *m = ListFactsRequest{} }
func (m *ListFactsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListFactsRequest) ProtoMessage()               {}
func (*ListFactsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ListFactsRequest) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *ListFactsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListFactsRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type FactList struct {
	Facts map[string]*Children `protobuf:"bytes,1,rep,name=facts" json:"facts,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FactList) Reset()                    { *m = FactList{} }
func (m *FactList) String() string            { return proto.CompactTextString(m) }
func (*FactList) ProtoMessage()               {}
func (*FactList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *FactList) GetFacts() map[string]*Children {
	if m != nil {
		return m.Facts
	}
	return nil
}

type Children struct {
	Child []string `protobuf:"bytes,1,rep,name=child" json:"child,omitempty"`
}

func (m *Children) Reset()                    { *m = Children{} }
func (m *Children) String() string            { return proto.CompactTextString(m) }
func (*Children) ProtoMessage()               {}
func (*Children) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Children) GetChild() []string {
	if m != nil {
		return m.Child
	}
	return nil
}

type ListLexiconsRequest struct {
}

func (m *ListLexiconsRequest) Reset()                    { *m = ListLexiconsRequest{} }
func (m *ListLexiconsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListLexiconsRequest) ProtoMessage()               {}
func (*ListLexiconsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type ListLexiconsReply struct {
	Lexicons []string `protobuf:"bytes,1,rep,name=lexicons" json:"lexicons,omitempty"`
}

func (m *ListLexiconsReply) Reset()                    { *m = ListLexiconsReply{} }
func (m *ListLexiconsReply) String() string            { return proto.CompactTextString(m) }
func (*ListLexiconsReply) ProtoMessage()               {}
func (*ListLexiconsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ListLexiconsReply) GetLexicons() []string {
	if m != nil {
		return m.Lexicons
	}
	return nil
}

type SessionRequest struct {
}

func (m *SessionRequest) Reset()                    { *m = SessionRequest{} }
func (m *SessionRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionRequest) ProtoMessage()               {}
func (*SessionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type SessionReply struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *SessionReply) Reset()                    { *m = SessionReply{} }
func (m *SessionReply) String() string            { return proto.CompactTextString(m) }
func (*SessionReply) ProtoMessage()               {}
func (*SessionReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SessionReply) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// The request message containing the CLQL source code.
type QueryRequest struct {
	Clql string `protobuf:"bytes,1,opt,name=clql" json:"clql,omitempty"`
}

func (m *QueryRequest) Reset()                    { *m = QueryRequest{} }
func (m *QueryRequest) String() string            { return proto.CompactTextString(m) }
func (*QueryRequest) ProtoMessage()               {}
func (*QueryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *QueryRequest) GetClql() string {
	if m != nil {
		return m.Clql
	}
	return ""
}

// The query response.
type QueryReply struct {
	Result string `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *QueryReply) Reset()                    { *m = QueryReply{} }
func (m *QueryReply) String() string            { return proto.CompactTextString(m) }
func (*QueryReply) ProtoMessage()               {}
func (*QueryReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *QueryReply) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

// The request message containing the files or directories to review.
type ReviewRequest struct {
	Key           string   `protobuf:"bytes,12,opt,name=key" json:"key,omitempty"`
	Host          string   `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	Owner         string   `protobuf:"bytes,2,opt,name=owner" json:"owner,omitempty"`
	Repo          string   `protobuf:"bytes,3,opt,name=repo" json:"repo,omitempty"`
	Sha           string   `protobuf:"bytes,4,opt,name=sha" json:"sha,omitempty"`
	FilesAndDirs  []string `protobuf:"bytes,5,rep,name=filesAndDirs" json:"filesAndDirs,omitempty"`
	Recursive     bool     `protobuf:"varint,6,opt,name=recursive" json:"recursive,omitempty"`
	Patches       []string `protobuf:"bytes,7,rep,name=Patches" json:"Patches,omitempty"`
	IsPullRequest bool     `protobuf:"varint,8,opt,name=isPullRequest" json:"isPullRequest,omitempty"`
	PullRequestID int64    `protobuf:"varint,9,opt,name=pullRequestID" json:"pullRequestID,omitempty"`
	Vcs           string   `protobuf:"bytes,10,opt,name=vcs" json:"vcs,omitempty"`
	Dotlingo      string   `protobuf:"bytes,11,opt,name=dotlingo" json:"dotlingo,omitempty"`
}

func (m *ReviewRequest) Reset()                    { *m = ReviewRequest{} }
func (m *ReviewRequest) String() string            { return proto.CompactTextString(m) }
func (*ReviewRequest) ProtoMessage()               {}
func (*ReviewRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ReviewRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *ReviewRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *ReviewRequest) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *ReviewRequest) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *ReviewRequest) GetSha() string {
	if m != nil {
		return m.Sha
	}
	return ""
}

func (m *ReviewRequest) GetFilesAndDirs() []string {
	if m != nil {
		return m.FilesAndDirs
	}
	return nil
}

func (m *ReviewRequest) GetRecursive() bool {
	if m != nil {
		return m.Recursive
	}
	return false
}

func (m *ReviewRequest) GetPatches() []string {
	if m != nil {
		return m.Patches
	}
	return nil
}

func (m *ReviewRequest) GetIsPullRequest() bool {
	if m != nil {
		return m.IsPullRequest
	}
	return false
}

func (m *ReviewRequest) GetPullRequestID() int64 {
	if m != nil {
		return m.PullRequestID
	}
	return 0
}

func (m *ReviewRequest) GetVcs() string {
	if m != nil {
		return m.Vcs
	}
	return ""
}

func (m *ReviewRequest) GetDotlingo() string {
	if m != nil {
		return m.Dotlingo
	}
	return ""
}

// Empty, we use the control queue once a review is started
type ReviewReply struct {
}

func (m *ReviewReply) Reset()                    { *m = ReviewReply{} }
func (m *ReviewReply) String() string            { return proto.CompactTextString(m) }
func (*ReviewReply) ProtoMessage()               {}
func (*ReviewReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

// Issue returned from a review.
type Issue struct {
	// The name of the issue.
	Name          string            `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Position      *IssueRange       `protobuf:"bytes,2,opt,name=position" json:"position,omitempty"`
	Comment       string            `protobuf:"bytes,3,opt,name=comment" json:"comment,omitempty"`
	CtxBefore     string            `protobuf:"bytes,4,opt,name=ctxBefore" json:"ctxBefore,omitempty"`
	LineText      string            `protobuf:"bytes,5,opt,name=lineText" json:"lineText,omitempty"`
	CtxAfter      string            `protobuf:"bytes,6,opt,name=ctxAfter" json:"ctxAfter,omitempty"`
	Metrics       map[string]string `protobuf:"bytes,7,rep,name=metrics" json:"metrics,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Tags          []string          `protobuf:"bytes,8,rep,name=tags" json:"tags,omitempty"`
	Link          string            `protobuf:"bytes,9,opt,name=link" json:"link,omitempty"`
	NewCode       bool              `protobuf:"varint,10,opt,name=newCode" json:"newCode,omitempty"`
	Patch         string            `protobuf:"bytes,11,opt,name=patch" json:"patch,omitempty"`
	Err           string            `protobuf:"bytes,12,opt,name=err" json:"err,omitempty"`
	Discard       bool              `protobuf:"varint,13,opt,name=discard" json:"discard,omitempty"`
	DiscardReason string            `protobuf:"bytes,14,opt,name=discardReason" json:"discardReason,omitempty"`
}

func (m *Issue) Reset()                    { *m = Issue{} }
func (m *Issue) String() string            { return proto.CompactTextString(m) }
func (*Issue) ProtoMessage()               {}
func (*Issue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Issue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Issue) GetPosition() *IssueRange {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Issue) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Issue) GetCtxBefore() string {
	if m != nil {
		return m.CtxBefore
	}
	return ""
}

func (m *Issue) GetLineText() string {
	if m != nil {
		return m.LineText
	}
	return ""
}

func (m *Issue) GetCtxAfter() string {
	if m != nil {
		return m.CtxAfter
	}
	return ""
}

func (m *Issue) GetMetrics() map[string]string {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *Issue) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Issue) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *Issue) GetNewCode() bool {
	if m != nil {
		return m.NewCode
	}
	return false
}

func (m *Issue) GetPatch() string {
	if m != nil {
		return m.Patch
	}
	return ""
}

func (m *Issue) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

func (m *Issue) GetDiscard() bool {
	if m != nil {
		return m.Discard
	}
	return false
}

func (m *Issue) GetDiscardReason() string {
	if m != nil {
		return m.DiscardReason
	}
	return ""
}

type IssueRange struct {
	Start *Position `protobuf:"bytes,1,opt,name=start" json:"start,omitempty"`
	End   *Position `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *IssueRange) Reset()                    { *m = IssueRange{} }
func (m *IssueRange) String() string            { return proto.CompactTextString(m) }
func (*IssueRange) ProtoMessage()               {}
func (*IssueRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *IssueRange) GetStart() *Position {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *IssueRange) GetEnd() *Position {
	if m != nil {
		return m.End
	}
	return nil
}

type Position struct {
	Filename string `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
	Offset   int64  `protobuf:"varint,2,opt,name=Offset" json:"Offset,omitempty"`
	Line     int64  `protobuf:"varint,3,opt,name=Line" json:"Line,omitempty"`
	Column   int64  `protobuf:"varint,4,opt,name=Column" json:"Column,omitempty"`
}

func (m *Position) Reset()                    { *m = Position{} }
func (m *Position) String() string            { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()               {}
func (*Position) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Position) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *Position) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Position) GetLine() int64 {
	if m != nil {
		return m.Line
	}
	return 0
}

func (m *Position) GetColumn() int64 {
	if m != nil {
		return m.Column
	}
	return 0
}

func init() {
	proto.RegisterType((*DescribeFactRequest)(nil), "codelingo.DescribeFactRequest")
	proto.RegisterType((*DescribeFactReply)(nil), "codelingo.DescribeFactReply")
	proto.RegisterType((*Property)(nil), "codelingo.Property")
	proto.RegisterType((*PathsFromOffsetRequest)(nil), "codelingo.PathsFromOffsetRequest")
	proto.RegisterType((*PathsFromOffsetReply)(nil), "codelingo.PathsFromOffsetReply")
	proto.RegisterType((*Path)(nil), "codelingo.Path")
	proto.RegisterType((*ListFactsRequest)(nil), "codelingo.ListFactsRequest")
	proto.RegisterType((*FactList)(nil), "codelingo.FactList")
	proto.RegisterType((*Children)(nil), "codelingo.Children")
	proto.RegisterType((*ListLexiconsRequest)(nil), "codelingo.ListLexiconsRequest")
	proto.RegisterType((*ListLexiconsReply)(nil), "codelingo.ListLexiconsReply")
	proto.RegisterType((*SessionRequest)(nil), "codelingo.SessionRequest")
	proto.RegisterType((*SessionReply)(nil), "codelingo.SessionReply")
	proto.RegisterType((*QueryRequest)(nil), "codelingo.QueryRequest")
	proto.RegisterType((*QueryReply)(nil), "codelingo.QueryReply")
	proto.RegisterType((*ReviewRequest)(nil), "codelingo.ReviewRequest")
	proto.RegisterType((*ReviewReply)(nil), "codelingo.ReviewReply")
	proto.RegisterType((*Issue)(nil), "codelingo.Issue")
	proto.RegisterType((*IssueRange)(nil), "codelingo.IssueRange")
	proto.RegisterType((*Position)(nil), "codelingo.Position")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CodeLingo service

type CodeLingoClient interface {
	// Initialise session
	Session(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*SessionReply, error)
	// Reviews files
	Review(ctx context.Context, in *ReviewRequest, opts ...grpc.CallOption) (*ReviewReply, error)
	// Queries source code
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryReply, error)
	// Lists available lexicons
	ListLexicons(ctx context.Context, in *ListLexiconsRequest, opts ...grpc.CallOption) (*ListLexiconsReply, error)
	ListFacts(ctx context.Context, in *ListFactsRequest, opts ...grpc.CallOption) (*FactList, error)
	PathsFromOffset(ctx context.Context, in *PathsFromOffsetRequest, opts ...grpc.CallOption) (*PathsFromOffsetReply, error)
	DescribeFact(ctx context.Context, in *DescribeFactRequest, opts ...grpc.CallOption) (*DescribeFactReply, error)
}

type codeLingoClient struct {
	cc *grpc.ClientConn
}

func NewCodeLingoClient(cc *grpc.ClientConn) CodeLingoClient {
	return &codeLingoClient{cc}
}

func (c *codeLingoClient) Session(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*SessionReply, error) {
	out := new(SessionReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/Session", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) Review(ctx context.Context, in *ReviewRequest, opts ...grpc.CallOption) (*ReviewReply, error) {
	out := new(ReviewReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/Review", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryReply, error) {
	out := new(QueryReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) ListLexicons(ctx context.Context, in *ListLexiconsRequest, opts ...grpc.CallOption) (*ListLexiconsReply, error) {
	out := new(ListLexiconsReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/ListLexicons", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) ListFacts(ctx context.Context, in *ListFactsRequest, opts ...grpc.CallOption) (*FactList, error) {
	out := new(FactList)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/ListFacts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) PathsFromOffset(ctx context.Context, in *PathsFromOffsetRequest, opts ...grpc.CallOption) (*PathsFromOffsetReply, error) {
	out := new(PathsFromOffsetReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/PathsFromOffset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) DescribeFact(ctx context.Context, in *DescribeFactRequest, opts ...grpc.CallOption) (*DescribeFactReply, error) {
	out := new(DescribeFactReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/DescribeFact", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CodeLingo service

type CodeLingoServer interface {
	// Initialise session
	Session(context.Context, *SessionRequest) (*SessionReply, error)
	// Reviews files
	Review(context.Context, *ReviewRequest) (*ReviewReply, error)
	// Queries source code
	Query(context.Context, *QueryRequest) (*QueryReply, error)
	// Lists available lexicons
	ListLexicons(context.Context, *ListLexiconsRequest) (*ListLexiconsReply, error)
	ListFacts(context.Context, *ListFactsRequest) (*FactList, error)
	PathsFromOffset(context.Context, *PathsFromOffsetRequest) (*PathsFromOffsetReply, error)
	DescribeFact(context.Context, *DescribeFactRequest) (*DescribeFactReply, error)
}

func RegisterCodeLingoServer(s *grpc.Server, srv CodeLingoServer) {
	s.RegisterService(&_CodeLingo_serviceDesc, srv)
}

func _CodeLingo_Session_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).Session(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/Session",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).Session(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_Review_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReviewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).Review(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/Review",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).Review(ctx, req.(*ReviewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).Query(ctx, req.(*QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_ListLexicons_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLexiconsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).ListLexicons(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/ListLexicons",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).ListLexicons(ctx, req.(*ListLexiconsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_ListFacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).ListFacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/ListFacts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).ListFacts(ctx, req.(*ListFactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_PathsFromOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathsFromOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).PathsFromOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/PathsFromOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).PathsFromOffset(ctx, req.(*PathsFromOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_DescribeFact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeFactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).DescribeFact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/DescribeFact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).DescribeFact(ctx, req.(*DescribeFactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CodeLingo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "codelingo.CodeLingo",
	HandlerType: (*CodeLingoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Session",
			Handler:    _CodeLingo_Session_Handler,
		},
		{
			MethodName: "Review",
			Handler:    _CodeLingo_Review_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _CodeLingo_Query_Handler,
		},
		{
			MethodName: "ListLexicons",
			Handler:    _CodeLingo_ListLexicons_Handler,
		},
		{
			MethodName: "ListFacts",
			Handler:    _CodeLingo_ListFacts_Handler,
		},
		{
			MethodName: "PathsFromOffset",
			Handler:    _CodeLingo_PathsFromOffset_Handler,
		},
		{
			MethodName: "DescribeFact",
			Handler:    _CodeLingo_DescribeFact_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "codelingo.proto",
}

func init() { proto.RegisterFile("codelingo.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1081 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x56, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0xce, 0x78, 0xe2, 0x64, 0x5c, 0x76, 0x7e, 0xb6, 0xf3, 0xc3, 0x60, 0x02, 0x98, 0xd6, 0xae,
	0x14, 0x2e, 0x41, 0x64, 0x91, 0x80, 0x15, 0x68, 0xd9, 0x24, 0xac, 0xb4, 0x52, 0x16, 0xcc, 0x80,
	0xd8, 0x1b, 0xd2, 0xec, 0x4c, 0x3b, 0x6e, 0x32, 0x9e, 0x99, 0xed, 0x6e, 0x3b, 0xf1, 0x0b, 0x70,
	0xe5, 0xc2, 0x13, 0xf0, 0x32, 0x3c, 0x05, 0xcf, 0x02, 0xaa, 0xfe, 0x19, 0xcf, 0xd8, 0x5e, 0x4e,
	0xdc, 0xaa, 0xaa, 0xab, 0xab, 0xab, 0xbe, 0xaa, 0xfe, 0xba, 0x61, 0x2f, 0x29, 0x52, 0x96, 0xf1,
	0xfc, 0xa6, 0x38, 0x2b, 0x45, 0xa1, 0x0a, 0xd2, 0xa9, 0x0c, 0x74, 0x02, 0x07, 0x57, 0x4c, 0x26,
	0x82, 0xbf, 0x66, 0xcf, 0xe3, 0x44, 0x45, 0xec, 0xcd, 0x94, 0x49, 0x45, 0x0e, 0xa1, 0x5d, 0xdc,
	0xe5, 0x4c, 0x84, 0xde, 0xc0, 0x3b, 0xed, 0x44, 0x46, 0x21, 0x04, 0x36, 0xf3, 0x78, 0xc2, 0xc2,
	0x96, 0x36, 0x6a, 0x99, 0x84, 0xb0, 0x3d, 0x63, 0x42, 0xf2, 0x22, 0x0f, 0x7d, 0x6d, 0x76, 0x2a,
	0x7a, 0x8f, 0xe2, 0x44, 0x85, 0x9b, 0xc6, 0x1b, 0x65, 0xfa, 0x9b, 0x07, 0x0f, 0x9a, 0xe7, 0x95,
	0xd9, 0x9c, 0x0c, 0xa0, 0x9b, 0x6a, 0x63, 0xa9, 0x30, 0x8e, 0x39, 0xb3, 0x6e, 0x22, 0x7d, 0x08,
	0xd8, 0x7d, 0x3c, 0x29, 0x33, 0x26, 0xed, 0xe9, 0x95, 0x4e, 0x1e, 0x03, 0x94, 0xa2, 0x28, 0x99,
	0x50, 0x9c, 0xc9, 0xd0, 0x1f, 0xf8, 0xa7, 0xdd, 0xf3, 0x83, 0xb3, 0x45, 0xcd, 0x43, 0xb3, 0x38,
	0x8f, 0x6a, 0x6e, 0xf4, 0x1b, 0x08, 0x9c, 0xbd, 0x2a, 0xcb, 0xab, 0x95, 0xb5, 0x94, 0x52, 0x6b,
	0x25, 0x25, 0xfa, 0x87, 0x07, 0xc7, 0xc3, 0x58, 0x8d, 0xe5, 0x73, 0x51, 0x4c, 0xbe, 0x1f, 0x8d,
	0x24, 0xab, 0xd0, 0x23, 0xb0, 0x99, 0xc5, 0xf9, 0x8d, 0x0b, 0x88, 0x32, 0xd9, 0x07, 0x3f, 0xe5,
	0xc2, 0x06, 0x42, 0x11, 0x6b, 0x1a, 0xf1, 0x8c, 0xe9, 0xa3, 0x0d, 0x74, 0x95, 0x8e, 0xde, 0x52,
	0x24, 0x16, 0x3a, 0x14, 0xb1, 0x23, 0x52, 0xc5, 0x42, 0x85, 0xed, 0x81, 0x77, 0xea, 0x47, 0x46,
	0x41, 0x3f, 0x96, 0xa7, 0xe1, 0x96, 0xb6, 0xa1, 0x48, 0xbf, 0x86, 0xc3, 0x95, 0xac, 0x10, 0xe3,
	0x47, 0xd0, 0x2e, 0xd1, 0x1e, 0x7a, 0x1a, 0xa0, 0xbd, 0x3a, 0x40, 0xb1, 0x1a, 0x47, 0x66, 0x95,
	0x9e, 0xc0, 0x26, 0xaa, 0x78, 0x5c, 0x5e, 0xa4, 0xcc, 0xb8, 0x77, 0x22, 0xa3, 0xd0, 0x9f, 0x61,
	0xff, 0x9a, 0x4b, 0x85, 0x9d, 0x93, 0xff, 0xe3, 0xa8, 0xd0, 0xdf, 0x3d, 0x08, 0x30, 0x28, 0x06,
	0x27, 0x9f, 0x41, 0x1b, 0x67, 0xc5, 0x65, 0xfa, 0x41, 0x2d, 0x53, 0xe7, 0xa3, 0x05, 0xf9, 0x6d,
	0xae, 0xc4, 0x3c, 0x32, 0xce, 0xfd, 0x97, 0x00, 0x0b, 0x23, 0xe2, 0x72, 0xcb, 0xe6, 0x36, 0x25,
	0x14, 0xc9, 0xc7, 0xd0, 0x9e, 0xc5, 0xd9, 0xd4, 0x64, 0xd4, 0x1c, 0x90, 0xcb, 0x31, 0xcf, 0x52,
	0xc1, 0xf2, 0xc8, 0x78, 0x3c, 0x69, 0x7d, 0xe1, 0xd1, 0x01, 0x04, 0xce, 0x8c, 0x15, 0x26, 0x28,
	0x3b, 0x2c, 0xb4, 0x42, 0x8f, 0xe0, 0x00, 0x53, 0xb9, 0x66, 0xf7, 0x3c, 0x29, 0x72, 0x07, 0x07,
	0xfd, 0x04, 0x1e, 0x34, 0xcd, 0x08, 0x7e, 0x1f, 0x82, 0xcc, 0x1a, 0x6c, 0x90, 0x4a, 0xa7, 0xfb,
	0xb0, 0xfb, 0x23, 0x93, 0x08, 0x83, 0x0b, 0x31, 0x80, 0x5e, 0x65, 0xc1, 0xdd, 0x2b, 0xc5, 0x50,
	0x0a, 0xbd, 0x1f, 0xa6, 0x4c, 0xcc, 0x6b, 0x03, 0x97, 0x64, 0x6f, 0x32, 0x37, 0x70, 0x28, 0xd3,
	0x87, 0x00, 0xd6, 0x07, 0x63, 0x1c, 0xc3, 0x96, 0x60, 0x72, 0x9a, 0x29, 0xeb, 0x63, 0x35, 0xfa,
	0x57, 0x0b, 0x76, 0x22, 0x36, 0xe3, 0xec, 0xce, 0xc5, 0xb2, 0xa7, 0xf5, 0x16, 0xd0, 0x11, 0xd8,
	0x1c, 0x17, 0xd2, 0xed, 0xd4, 0xf2, 0xa2, 0xeb, 0xad, 0xa5, 0xae, 0x0b, 0x56, 0x16, 0xb6, 0xbd,
	0x5a, 0xd6, 0xa3, 0x3c, 0x8e, 0xab, 0x51, 0x1e, 0xc7, 0x84, 0x42, 0x0f, 0x07, 0x5d, 0x3e, 0xcb,
	0xd3, 0x2b, 0x2e, 0x64, 0xd8, 0xd6, 0x88, 0x34, 0x6c, 0xe4, 0x04, 0x3a, 0x82, 0x25, 0x53, 0x21,
	0xf9, 0x8c, 0xe9, 0xf1, 0x0e, 0xa2, 0x85, 0x01, 0x27, 0x69, 0x18, 0xab, 0x64, 0xcc, 0x64, 0xb8,
	0xad, 0x37, 0x3b, 0x95, 0x3c, 0x84, 0x1d, 0x2e, 0x87, 0xd3, 0x2c, 0xb3, 0xe5, 0x84, 0x81, 0xde,
	0xdb, 0x34, 0xa2, 0x57, 0xb9, 0x50, 0x5f, 0x5c, 0x85, 0x1d, 0x7d, 0x81, 0x9a, 0x46, 0xcc, 0x7c,
	0x96, 0xc8, 0x10, 0x4c, 0xe6, 0xb3, 0x44, 0x62, 0x1f, 0xd3, 0x42, 0xe9, 0xa9, 0x09, 0xbb, 0xe6,
	0xca, 0x3a, 0x9d, 0xee, 0x40, 0xd7, 0x01, 0x59, 0x66, 0x73, 0xfa, 0xb7, 0x0f, 0xed, 0x17, 0x52,
	0x4e, 0xd9, 0x5a, 0x7a, 0xf9, 0x14, 0x82, 0xb2, 0x90, 0xbc, 0xe2, 0x96, 0xee, 0xf9, 0x51, 0x6d,
	0x20, 0xf5, 0xbe, 0x28, 0xce, 0x6f, 0x58, 0x54, 0xb9, 0x61, 0xcd, 0x49, 0x31, 0x99, 0xb0, 0x5c,
	0xb9, 0xdb, 0x63, 0x55, 0xc4, 0x2a, 0x51, 0xf7, 0x17, 0x6c, 0x54, 0x08, 0x66, 0x71, 0x5e, 0x18,
	0xf4, 0xec, 0xf1, 0x9c, 0xfd, 0xc4, 0xee, 0x0d, 0x77, 0xe0, 0xec, 0x59, 0x1d, 0xd7, 0x12, 0x75,
	0xff, 0x6c, 0xa4, 0x98, 0xd0, 0x20, 0x77, 0xa2, 0x4a, 0x27, 0x9f, 0xc3, 0xf6, 0x84, 0x29, 0xc1,
	0x13, 0x83, 0x71, 0xf7, 0xfc, 0xfd, 0xe5, 0x0c, 0xcf, 0x5e, 0x9a, 0x75, 0x73, 0x0f, 0x9d, 0x37,
	0xd6, 0xab, 0xe2, 0x1b, 0x19, 0x06, 0xba, 0x33, 0x5a, 0xd6, 0x8c, 0xc8, 0xf3, 0x5b, 0x8d, 0x33,
	0x32, 0x22, 0xcf, 0x6f, 0xb1, 0xa0, 0x9c, 0xdd, 0x5d, 0x16, 0x29, 0xd3, 0x10, 0x07, 0x91, 0x53,
	0x71, 0xb8, 0x4a, 0xec, 0xa7, 0xc5, 0xd8, 0x28, 0x9a, 0xeb, 0x84, 0x70, 0x83, 0xc9, 0x84, 0xc0,
	0x08, 0x29, 0x97, 0x49, 0x2c, 0xd2, 0x70, 0xc7, 0x44, 0xb0, 0x2a, 0x36, 0xd8, 0x8a, 0x11, 0x8b,
	0x65, 0x91, 0x87, 0xbb, 0x7a, 0x57, 0xd3, 0xd8, 0x7f, 0x02, 0xbd, 0x7a, 0x09, 0x6b, 0x58, 0xe3,
	0xb0, 0xce, 0x1a, 0x9d, 0x3a, 0x41, 0xfc, 0x02, 0xb0, 0x68, 0x13, 0xb2, 0x8b, 0x61, 0x67, 0x6f,
	0x85, 0x5d, 0x86, 0xb6, 0x81, 0x8e, 0xb2, 0x1f, 0x19, 0xca, 0x6e, 0xbd, 0xdd, 0x51, 0xf3, 0xf8,
	0xaf, 0x10, 0x38, 0x43, 0xe3, 0xa5, 0xf0, 0x96, 0x5e, 0x8a, 0x63, 0xd8, 0x32, 0x34, 0xaf, 0x23,
	0xfa, 0x91, 0xd5, 0x10, 0xf1, 0x6b, 0x9e, 0x9b, 0x97, 0xc5, 0x8f, 0xb4, 0x8c, 0xbe, 0x97, 0x45,
	0x36, 0x9d, 0xe4, 0x7a, 0x4a, 0xfc, 0xc8, 0x6a, 0xe7, 0xff, 0xf8, 0xd0, 0x41, 0xe0, 0xaf, 0x31,
	0x0f, 0xf2, 0x14, 0xb6, 0x2d, 0xfd, 0x90, 0x77, 0x6b, 0xe9, 0x35, 0x49, 0xaa, 0xff, 0xce, 0xba,
	0x25, 0x1c, 0xfc, 0x0d, 0xf2, 0x15, 0x6c, 0x99, 0x9b, 0x40, 0xc2, 0x9a, 0x53, 0x83, 0x65, 0xfa,
	0xc7, 0x6b, 0x56, 0xcc, 0xee, 0x2f, 0xa1, 0xad, 0x79, 0x8b, 0xd4, 0x4f, 0xa8, 0xb3, 0x5d, 0xff,
	0x68, 0x75, 0xc1, 0x6c, 0xfd, 0x0e, 0x7a, 0x75, 0xee, 0x25, 0xf5, 0xa7, 0x63, 0x0d, 0x57, 0xf7,
	0x4f, 0xde, 0xba, 0x6e, 0xe2, 0x3d, 0x85, 0x4e, 0xf5, 0xdc, 0x91, 0xf7, 0x96, 0x9c, 0xeb, 0x8f,
	0x60, 0xff, 0x60, 0xcd, 0x23, 0x45, 0x37, 0xc8, 0x2b, 0xd8, 0x5b, 0x7a, 0x8c, 0xc9, 0x47, 0x4b,
	0x0f, 0xef, 0xea, 0xf7, 0xa1, 0xff, 0xe1, 0x7f, 0xb9, 0x54, 0x95, 0xd6, 0xbf, 0x51, 0x8d, 0x4a,
	0xd7, 0xfc, 0xe7, 0x1a, 0x95, 0xae, 0xfc, 0xbf, 0xe8, 0xc6, 0xc5, 0x19, 0x1c, 0xf2, 0xa2, 0xe6,
	0x73, 0x23, 0xca, 0xe4, 0x2c, 0xc9, 0x2e, 0x76, 0xab, 0xb1, 0x18, 0xe2, 0xcf, 0x71, 0xe8, 0xfd,
	0xd9, 0xf2, 0x2f, 0xaf, 0x5f, 0xbd, 0xde, 0xd2, 0x1f, 0xc9, 0xc7, 0xff, 0x06, 0x00, 0x00, 0xff,
	0xff, 0xdf, 0x9d, 0x63, 0x3e, 0x5b, 0x0a, 0x00, 0x00,
}

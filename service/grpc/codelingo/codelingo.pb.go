// Code generated by protoc-gen-go.
// source: codelingo.proto
// DO NOT EDIT!

/*
Package codelingo is a generated protocol buffer package.

It is generated from these files:
	codelingo.proto

It has these top-level messages:
	QueryRequest
	QueryReply
	ReviewRequest
	ReviewReply
	Issue
	IssueRange
	Position
*/
package codelingo

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The request message containing the CLQL source code.
type QueryRequest struct {
	Clql string `protobuf:"bytes,1,opt,name=clql" json:"clql,omitempty"`
}

func (m *QueryRequest) Reset()                    { *m = QueryRequest{} }
func (m *QueryRequest) String() string            { return proto.CompactTextString(m) }
func (*QueryRequest) ProtoMessage()               {}
func (*QueryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// The query response.
type QueryReply struct {
	Result string `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *QueryReply) Reset()                    { *m = QueryReply{} }
func (m *QueryReply) String() string            { return proto.CompactTextString(m) }
func (*QueryReply) ProtoMessage()               {}
func (*QueryReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// The request message containing the files or directories to review.
type ReviewRequest struct {
	Host          string   `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	Owner         string   `protobuf:"bytes,2,opt,name=owner" json:"owner,omitempty"`
	Repo          string   `protobuf:"bytes,3,opt,name=repo" json:"repo,omitempty"`
	Sha           string   `protobuf:"bytes,4,opt,name=sha" json:"sha,omitempty"`
	FilesAndDirs  []string `protobuf:"bytes,5,rep,name=filesAndDirs" json:"filesAndDirs,omitempty"`
	Recursive     bool     `protobuf:"varint,6,opt,name=recursive" json:"recursive,omitempty"`
	Patches       []string `protobuf:"bytes,7,rep,name=Patches" json:"Patches,omitempty"`
	IsPullRequest bool     `protobuf:"varint,8,opt,name=isPullRequest" json:"isPullRequest,omitempty"`
	PullRequestID int64    `protobuf:"varint,9,opt,name=pullRequestID" json:"pullRequestID,omitempty"`
	Vcs           string   `protobuf:"bytes,10,opt,name=vcs" json:"vcs,omitempty"`
	Dotlingo      string   `protobuf:"bytes,11,opt,name=dotlingo" json:"dotlingo,omitempty"`
}

func (m *ReviewRequest) Reset()                    { *m = ReviewRequest{} }
func (m *ReviewRequest) String() string            { return proto.CompactTextString(m) }
func (*ReviewRequest) ProtoMessage()               {}
func (*ReviewRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type ReviewReply struct {
	Issues []*Issue `protobuf:"bytes,1,rep,name=issues" json:"issues,omitempty"`
}

func (m *ReviewReply) Reset()                    { *m = ReviewReply{} }
func (m *ReviewReply) String() string            { return proto.CompactTextString(m) }
func (*ReviewReply) ProtoMessage()               {}
func (*ReviewReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ReviewReply) GetIssues() []*Issue {
	if m != nil {
		return m.Issues
	}
	return nil
}

// Issue returned from a review.
type Issue struct {
	// The name of the issue.
	Name          string            `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Position      *IssueRange       `protobuf:"bytes,2,opt,name=position" json:"position,omitempty"`
	Comment       string            `protobuf:"bytes,3,opt,name=comment" json:"comment,omitempty"`
	CtxBefore     string            `protobuf:"bytes,4,opt,name=ctxBefore" json:"ctxBefore,omitempty"`
	LineText      string            `protobuf:"bytes,5,opt,name=lineText" json:"lineText,omitempty"`
	CtxAfter      string            `protobuf:"bytes,6,opt,name=ctxAfter" json:"ctxAfter,omitempty"`
	Metrics       map[string]string `protobuf:"bytes,7,rep,name=metrics" json:"metrics,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Tags          []string          `protobuf:"bytes,8,rep,name=tags" json:"tags,omitempty"`
	Link          string            `protobuf:"bytes,9,opt,name=link" json:"link,omitempty"`
	NewCode       bool              `protobuf:"varint,10,opt,name=newCode" json:"newCode,omitempty"`
	Patch         string            `protobuf:"bytes,11,opt,name=patch" json:"patch,omitempty"`
	Err           string            `protobuf:"bytes,12,opt,name=err" json:"err,omitempty"`
	Discard       bool              `protobuf:"varint,13,opt,name=discard" json:"discard,omitempty"`
	DiscardReason string            `protobuf:"bytes,14,opt,name=discardReason" json:"discardReason,omitempty"`
}

func (m *Issue) Reset()                    { *m = Issue{} }
func (m *Issue) String() string            { return proto.CompactTextString(m) }
func (*Issue) ProtoMessage()               {}
func (*Issue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Issue) GetPosition() *IssueRange {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Issue) GetMetrics() map[string]string {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type IssueRange struct {
	Start *Position `protobuf:"bytes,1,opt,name=start" json:"start,omitempty"`
	End   *Position `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *IssueRange) Reset()                    { *m = IssueRange{} }
func (m *IssueRange) String() string            { return proto.CompactTextString(m) }
func (*IssueRange) ProtoMessage()               {}
func (*IssueRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *IssueRange) GetStart() *Position {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *IssueRange) GetEnd() *Position {
	if m != nil {
		return m.End
	}
	return nil
}

type Position struct {
	Filename string `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
	Offset   int64  `protobuf:"varint,2,opt,name=Offset" json:"Offset,omitempty"`
	Line     int64  `protobuf:"varint,3,opt,name=Line" json:"Line,omitempty"`
	Column   int64  `protobuf:"varint,4,opt,name=Column" json:"Column,omitempty"`
}

func (m *Position) Reset()                    { *m = Position{} }
func (m *Position) String() string            { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()               {}
func (*Position) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func init() {
	proto.RegisterType((*QueryRequest)(nil), "codelingo.QueryRequest")
	proto.RegisterType((*QueryReply)(nil), "codelingo.QueryReply")
	proto.RegisterType((*ReviewRequest)(nil), "codelingo.ReviewRequest")
	proto.RegisterType((*ReviewReply)(nil), "codelingo.ReviewReply")
	proto.RegisterType((*Issue)(nil), "codelingo.Issue")
	proto.RegisterType((*IssueRange)(nil), "codelingo.IssueRange")
	proto.RegisterType((*Position)(nil), "codelingo.Position")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for CodeLingo service

type CodeLingoClient interface {
	Review(ctx context.Context, in *ReviewRequest, opts ...grpc.CallOption) (*ReviewReply, error)
	// Queries source code
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryReply, error)
}

type codeLingoClient struct {
	cc *grpc.ClientConn
}

func NewCodeLingoClient(cc *grpc.ClientConn) CodeLingoClient {
	return &codeLingoClient{cc}
}

func (c *codeLingoClient) Review(ctx context.Context, in *ReviewRequest, opts ...grpc.CallOption) (*ReviewReply, error) {
	out := new(ReviewReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/Review", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryReply, error) {
	out := new(QueryReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CodeLingo service

type CodeLingoServer interface {
	Review(context.Context, *ReviewRequest) (*ReviewReply, error)
	// Queries source code
	Query(context.Context, *QueryRequest) (*QueryReply, error)
}

func RegisterCodeLingoServer(s *grpc.Server, srv CodeLingoServer) {
	s.RegisterService(&_CodeLingo_serviceDesc, srv)
}

func _CodeLingo_Review_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReviewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).Review(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/Review",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).Review(ctx, req.(*ReviewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).Query(ctx, req.(*QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CodeLingo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "codelingo.CodeLingo",
	HandlerType: (*CodeLingoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Review",
			Handler:    _CodeLingo_Review_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _CodeLingo_Query_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("codelingo.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 586 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x94, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0x71, 0xdc, 0xb8, 0xf6, 0x38, 0x69, 0x8b, 0x69, 0x61, 0x55, 0x81, 0x54, 0xf9, 0x42,
	0x4f, 0x46, 0x0a, 0x17, 0x40, 0x5c, 0xfa, 0x87, 0x43, 0x51, 0x11, 0x21, 0x42, 0xe2, 0x6c, 0xec,
	0x49, 0xba, 0xaa, 0xe3, 0x75, 0x77, 0xd7, 0x69, 0x73, 0xe7, 0x49, 0x78, 0x20, 0xae, 0xbc, 0x0e,
	0xb3, 0x6b, 0x27, 0x71, 0x4b, 0x6f, 0xf1, 0x7c, 0xb3, 0x3b, 0xf3, 0xfd, 0x66, 0x36, 0xb0, 0x9b,
	0x89, 0x1c, 0x0b, 0x5e, 0xce, 0x44, 0x52, 0x49, 0xa1, 0x45, 0x14, 0xac, 0x03, 0xf1, 0x4b, 0x18,
	0x7c, 0xab, 0x51, 0x2e, 0x27, 0x78, 0x53, 0xa3, 0xd2, 0xd1, 0x00, 0xb6, 0xb2, 0xe2, 0xa6, 0x60,
	0xce, 0x91, 0x73, 0x1c, 0x90, 0x0a, 0xad, 0x5a, 0x15, 0xcb, 0x68, 0x07, 0x3c, 0x89, 0xaa, 0x2e,
	0x74, 0xab, 0xfe, 0x71, 0x60, 0x38, 0xc1, 0x05, 0xc7, 0xdb, 0xce, 0xe9, 0x2b, 0xa1, 0x5a, 0x3d,
	0x1a, 0x42, 0x5f, 0xdc, 0x96, 0x28, 0x59, 0xcf, 0x7e, 0x92, 0x28, 0xb1, 0x12, 0xcc, 0xb5, 0x5f,
	0x21, 0xb8, 0xea, 0x2a, 0x65, 0x5b, 0xf6, 0x63, 0x1f, 0x06, 0x53, 0x5e, 0xa0, 0x3a, 0x29, 0xf3,
	0x73, 0x2e, 0x15, 0xeb, 0x1f, 0xb9, 0x14, 0x7d, 0x0a, 0x81, 0xc4, 0xac, 0x96, 0x8a, 0x2f, 0x90,
	0x79, 0x94, 0xe8, 0x47, 0xbb, 0xb0, 0x3d, 0x4e, 0x75, 0x76, 0x85, 0x8a, 0x6d, 0xdb, 0x9c, 0x03,
	0x18, 0x72, 0x35, 0xae, 0x8b, 0xa2, 0x6d, 0x81, 0xf9, 0x36, 0x8f, 0xc2, 0xd5, 0x26, 0x78, 0x71,
	0xce, 0x02, 0x0a, 0xbb, 0xa6, 0xe8, 0x22, 0x53, 0x0c, 0x6c, 0xd1, 0x3d, 0xf0, 0x73, 0xa1, 0x2d,
	0x06, 0x16, 0x5a, 0x43, 0x6f, 0x20, 0x5c, 0xf9, 0x31, 0x7e, 0x8f, 0xc0, 0xe3, 0x4a, 0xd1, 0x05,
	0xe4, 0xc7, 0x3d, 0x0e, 0x47, 0x7b, 0xc9, 0x06, 0xe4, 0x85, 0x11, 0xe2, 0xbf, 0x3d, 0xe8, 0xdb,
	0x5f, 0xc6, 0x5c, 0x99, 0xce, 0xb1, 0x75, 0xfe, 0x1a, 0xfc, 0x4a, 0x28, 0xae, 0xb9, 0x28, 0xad,
	0xf9, 0x70, 0x74, 0xf0, 0xf0, 0xec, 0x24, 0x2d, 0x67, 0x68, 0xfc, 0x64, 0x62, 0x3e, 0xc7, 0x52,
	0xb7, 0x58, 0xc8, 0x73, 0xa6, 0xef, 0x4e, 0x71, 0x2a, 0x24, 0xb6, 0x70, 0xa8, 0x4f, 0x3a, 0x87,
	0xdf, 0xf1, 0x4e, 0x13, 0x98, 0x36, 0x42, 0x49, 0x27, 0x53, 0x4d, 0x6c, 0x3d, 0x1b, 0x49, 0x60,
	0x7b, 0x8e, 0x5a, 0xf2, 0xac, 0xe1, 0x12, 0x8e, 0x5e, 0x3d, 0xac, 0x97, 0x7c, 0x69, 0xf4, 0x4f,
	0xa5, 0x96, 0x4b, 0xd3, 0xae, 0x4e, 0x67, 0x8a, 0x68, 0xb9, 0xcd, 0x64, 0x28, 0xf3, 0xda, 0x42,
	0x0a, 0x4c, 0x4f, 0x25, 0xde, 0x9e, 0xd1, 0x71, 0x0b, 0xca, 0x37, 0x73, 0xac, 0x0c, 0xf4, 0x86,
	0x92, 0x81, 0x88, 0x52, 0xb2, 0xc1, 0x2a, 0x39, 0xe7, 0x2a, 0x4b, 0x65, 0xce, 0x86, 0x2b, 0xf2,
	0x6d, 0x60, 0x82, 0xa9, 0x22, 0xff, 0x3b, 0x26, 0xef, 0x30, 0x81, 0xc1, 0xbd, 0x06, 0xe8, 0x92,
	0x6b, 0x5c, 0x6e, 0x16, 0x65, 0x91, 0x16, 0x35, 0x36, 0x8b, 0xf2, 0xa1, 0xf7, 0xce, 0x89, 0x27,
	0x00, 0x1d, 0x4c, 0x31, 0xf4, 0x95, 0x4e, 0x65, 0xb3, 0x58, 0xe1, 0xe8, 0x59, 0xc7, 0xdc, 0xb8,
	0xe5, 0x4c, 0xd3, 0x72, 0xb1, 0xcc, 0x5b, 0xdc, 0x8f, 0x65, 0xc4, 0x9f, 0xc1, 0x5f, 0x67, 0x13,
	0x42, 0xb3, 0x71, 0x9d, 0x99, 0xd1, 0x76, 0x7f, 0x9d, 0x4e, 0x15, 0x6a, 0x7b, 0x85, 0x6b, 0xa0,
	0x5c, 0x12, 0x76, 0x3b, 0x17, 0xd7, 0xa8, 0x67, 0xa2, 0xa8, 0xe7, 0xa5, 0x1d, 0x8a, 0x3b, 0xfa,
	0xe5, 0x40, 0x60, 0x10, 0x5d, 0x9a, 0x12, 0xd1, 0x47, 0xf0, 0x9a, 0xc5, 0x89, 0x58, 0xa7, 0xf0,
	0xbd, 0xb7, 0x71, 0xf8, 0xfc, 0x11, 0x85, 0xb6, 0x2c, 0x7e, 0x12, 0xbd, 0x87, 0xbe, 0x7d, 0x65,
	0xd1, 0x8b, 0x4e, 0x4a, 0xf7, 0x55, 0x1e, 0x1e, 0xfc, 0x2f, 0xd8, 0xa3, 0xa7, 0x09, 0xec, 0x73,
	0xd1, 0x11, 0x67, 0xb2, 0xca, 0x92, 0xac, 0x38, 0xdd, 0x59, 0xf7, 0x36, 0x36, 0x2f, 0x7e, 0xec,
	0xfc, 0xee, 0xb9, 0x67, 0x97, 0x3f, 0x7e, 0x7a, 0xf6, 0x0f, 0xe0, 0xed, 0xbf, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x83, 0xad, 0x17, 0xe2, 0x13, 0x04, 0x00, 0x00,
}

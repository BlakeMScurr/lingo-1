// Code generated by protoc-gen-go.
// source: github.com/codelingo/lingo/service/grpc/codelingo/codelingo.proto
// DO NOT EDIT!

/*
Package codelingo is a generated protocol buffer package.

It is generated from these files:
	github.com/codelingo/lingo/service/grpc/codelingo/codelingo.proto

It has these top-level messages:
	DescribeFactRequest
	DescribeFactReply
	Property
	PathsFromOffsetRequest
	PathsFromOffsetReply
	Path
	ListFactsRequest
	FactList
	Children
	ListLexiconsRequest
	ListLexiconsReply
	SessionRequest
	SessionReply
	QueryRequest
	MetaDatum
	QueryReply
	ReviewRequest
	Issue
	IssueRange
	Position
	LatestClientVersionRequest
	LatestClientVersionReply
*/
package codelingo

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import inner "github.com/codelingo/clql/inner"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DescribeFactRequest struct {
	Owner   string `protobuf:"bytes,1,opt,name=owner" json:"owner,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
	Fact    string `protobuf:"bytes,4,opt,name=fact" json:"fact,omitempty"`
}

func (m *DescribeFactRequest) Reset()                    { *m = DescribeFactRequest{} }
func (m *DescribeFactRequest) String() string            { return proto.CompactTextString(m) }
func (*DescribeFactRequest) ProtoMessage()               {}
func (*DescribeFactRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DescribeFactRequest) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *DescribeFactRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DescribeFactRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *DescribeFactRequest) GetFact() string {
	if m != nil {
		return m.Fact
	}
	return ""
}

type DescribeFactReply struct {
	Description string      `protobuf:"bytes,1,opt,name=description" json:"description,omitempty"`
	Examples    string      `protobuf:"bytes,2,opt,name=examples" json:"examples,omitempty"`
	Properties  []*Property `protobuf:"bytes,3,rep,name=properties" json:"properties,omitempty"`
}

func (m *DescribeFactReply) Reset()                    { *m = DescribeFactReply{} }
func (m *DescribeFactReply) String() string            { return proto.CompactTextString(m) }
func (*DescribeFactReply) ProtoMessage()               {}
func (*DescribeFactReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DescribeFactReply) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DescribeFactReply) GetExamples() string {
	if m != nil {
		return m.Examples
	}
	return ""
}

func (m *DescribeFactReply) GetProperties() []*Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

type Property struct {
	Name        string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
}

func (m *Property) Reset()                    { *m = Property{} }
func (m *Property) String() string            { return proto.CompactTextString(m) }
func (*Property) ProtoMessage()               {}
func (*Property) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Property) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Property) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type PathsFromOffsetRequest struct {
	Lang     string `protobuf:"bytes,1,opt,name=lang" json:"lang,omitempty"`
	Dir      string `protobuf:"bytes,2,opt,name=dir" json:"dir,omitempty"`
	Filename string `protobuf:"bytes,3,opt,name=filename" json:"filename,omitempty"`
	Src      string `protobuf:"bytes,4,opt,name=src" json:"src,omitempty"`
	Start    int64  `protobuf:"varint,5,opt,name=start" json:"start,omitempty"`
	End      int64  `protobuf:"varint,6,opt,name=end" json:"end,omitempty"`
}

func (m *PathsFromOffsetRequest) Reset()                    { *m = PathsFromOffsetRequest{} }
func (m *PathsFromOffsetRequest) String() string            { return proto.CompactTextString(m) }
func (*PathsFromOffsetRequest) ProtoMessage()               {}
func (*PathsFromOffsetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *PathsFromOffsetRequest) GetLang() string {
	if m != nil {
		return m.Lang
	}
	return ""
}

func (m *PathsFromOffsetRequest) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *PathsFromOffsetRequest) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *PathsFromOffsetRequest) GetSrc() string {
	if m != nil {
		return m.Src
	}
	return ""
}

func (m *PathsFromOffsetRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *PathsFromOffsetRequest) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

type PathsFromOffsetReply struct {
	Paths []*Path `protobuf:"bytes,1,rep,name=paths" json:"paths,omitempty"`
}

func (m *PathsFromOffsetReply) Reset()                    { *m = PathsFromOffsetReply{} }
func (m *PathsFromOffsetReply) String() string            { return proto.CompactTextString(m) }
func (*PathsFromOffsetReply) ProtoMessage()               {}
func (*PathsFromOffsetReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PathsFromOffsetReply) GetPaths() []*Path {
	if m != nil {
		return m.Paths
	}
	return nil
}

type Path struct {
	Nodes []string `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Path) GetNodes() []string {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type ListFactsRequest struct {
	Owner   string `protobuf:"bytes,1,opt,name=owner" json:"owner,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
}

func (m *ListFactsRequest) Reset()                    { *m = ListFactsRequest{} }
func (m *ListFactsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListFactsRequest) ProtoMessage()               {}
func (*ListFactsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ListFactsRequest) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *ListFactsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListFactsRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type FactList struct {
	Facts map[string]*Children `protobuf:"bytes,1,rep,name=facts" json:"facts,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FactList) Reset()                    { *m = FactList{} }
func (m *FactList) String() string            { return proto.CompactTextString(m) }
func (*FactList) ProtoMessage()               {}
func (*FactList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *FactList) GetFacts() map[string]*Children {
	if m != nil {
		return m.Facts
	}
	return nil
}

type Children struct {
	Child []string `protobuf:"bytes,1,rep,name=child" json:"child,omitempty"`
}

func (m *Children) Reset()                    { *m = Children{} }
func (m *Children) String() string            { return proto.CompactTextString(m) }
func (*Children) ProtoMessage()               {}
func (*Children) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Children) GetChild() []string {
	if m != nil {
		return m.Child
	}
	return nil
}

type ListLexiconsRequest struct {
}

func (m *ListLexiconsRequest) Reset()                    { *m = ListLexiconsRequest{} }
func (m *ListLexiconsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListLexiconsRequest) ProtoMessage()               {}
func (*ListLexiconsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type ListLexiconsReply struct {
	Lexicons []string `protobuf:"bytes,1,rep,name=lexicons" json:"lexicons,omitempty"`
}

func (m *ListLexiconsReply) Reset()                    { *m = ListLexiconsReply{} }
func (m *ListLexiconsReply) String() string            { return proto.CompactTextString(m) }
func (*ListLexiconsReply) ProtoMessage()               {}
func (*ListLexiconsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ListLexiconsReply) GetLexicons() []string {
	if m != nil {
		return m.Lexicons
	}
	return nil
}

type SessionRequest struct {
}

func (m *SessionRequest) Reset()                    { *m = SessionRequest{} }
func (m *SessionRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionRequest) ProtoMessage()               {}
func (*SessionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type SessionReply struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *SessionReply) Reset()                    { *m = SessionReply{} }
func (m *SessionReply) String() string            { return proto.CompactTextString(m) }
func (*SessionReply) ProtoMessage()               {}
func (*SessionReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SessionReply) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// The request message containing the CLQL source code.
type QueryRequest struct {
	Query    *inner.Query          `protobuf:"bytes,1,opt,name=query" json:"query,omitempty"`
	Metadata map[string]*MetaDatum `protobuf:"bytes,2,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *QueryRequest) Reset()                    { *m = QueryRequest{} }
func (m *QueryRequest) String() string            { return proto.CompactTextString(m) }
func (*QueryRequest) ProtoMessage()               {}
func (*QueryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *QueryRequest) GetQuery() *inner.Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *QueryRequest) GetMetadata() map[string]*MetaDatum {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// Possible values correspond with in platform/controller/graphdb/query/result
type MetaDatum struct {
	// Types that are valid to be assigned to Datum:
	//	*MetaDatum_String_
	//	*MetaDatum_Int
	//	*MetaDatum_Bool
	Datum isMetaDatum_Datum `protobuf_oneof:"datum"`
}

func (m *MetaDatum) Reset()                    { *m = MetaDatum{} }
func (m *MetaDatum) String() string            { return proto.CompactTextString(m) }
func (*MetaDatum) ProtoMessage()               {}
func (*MetaDatum) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type isMetaDatum_Datum interface {
	isMetaDatum_Datum()
}

type MetaDatum_String_ struct {
	String_ string `protobuf:"bytes,1,opt,name=string,oneof"`
}
type MetaDatum_Int struct {
	Int int64 `protobuf:"varint,2,opt,name=int,oneof"`
}
type MetaDatum_Bool struct {
	Bool bool `protobuf:"varint,3,opt,name=bool,oneof"`
}

func (*MetaDatum_String_) isMetaDatum_Datum() {}
func (*MetaDatum_Int) isMetaDatum_Datum()     {}
func (*MetaDatum_Bool) isMetaDatum_Datum()    {}

func (m *MetaDatum) GetDatum() isMetaDatum_Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

func (m *MetaDatum) GetString_() string {
	if x, ok := m.GetDatum().(*MetaDatum_String_); ok {
		return x.String_
	}
	return ""
}

func (m *MetaDatum) GetInt() int64 {
	if x, ok := m.GetDatum().(*MetaDatum_Int); ok {
		return x.Int
	}
	return 0
}

func (m *MetaDatum) GetBool() bool {
	if x, ok := m.GetDatum().(*MetaDatum_Bool); ok {
		return x.Bool
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MetaDatum) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MetaDatum_OneofMarshaler, _MetaDatum_OneofUnmarshaler, _MetaDatum_OneofSizer, []interface{}{
		(*MetaDatum_String_)(nil),
		(*MetaDatum_Int)(nil),
		(*MetaDatum_Bool)(nil),
	}
}

func _MetaDatum_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MetaDatum)
	// datum
	switch x := m.Datum.(type) {
	case *MetaDatum_String_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.String_)
	case *MetaDatum_Int:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Int))
	case *MetaDatum_Bool:
		t := uint64(0)
		if x.Bool {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("MetaDatum.Datum has unexpected type %T", x)
	}
	return nil
}

func _MetaDatum_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MetaDatum)
	switch tag {
	case 1: // datum.string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Datum = &MetaDatum_String_{x}
		return true, err
	case 2: // datum.int
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Datum = &MetaDatum_Int{int64(x)}
		return true, err
	case 3: // datum.bool
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Datum = &MetaDatum_Bool{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _MetaDatum_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MetaDatum)
	// datum
	switch x := m.Datum.(type) {
	case *MetaDatum_String_:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.String_)))
		n += len(x.String_)
	case *MetaDatum_Int:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int))
	case *MetaDatum_Bool:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The query response.
type QueryReply struct {
	Uid        string                           `protobuf:"bytes,1,opt,name=uid" json:"uid,omitempty"`
	Data       map[string]*QueryReply_DataField `protobuf:"bytes,3,rep,name=data" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Error      string                           `protobuf:"bytes,4,opt,name=error" json:"error,omitempty"`
	Depth      int64                            `protobuf:"varint,5,opt,name=depth" json:"depth,omitempty"`
	FactName   string                           `protobuf:"bytes,6,opt,name=factName" json:"factName,omitempty"`
	Decorators []*inner.Decorator               `protobuf:"bytes,7,rep,name=decorators" json:"decorators,omitempty"`
	Children   []*QueryReply                    `protobuf:"bytes,8,rep,name=children" json:"children,omitempty"`
}

func (m *QueryReply) Reset()                    { *m = QueryReply{} }
func (m *QueryReply) String() string            { return proto.CompactTextString(m) }
func (*QueryReply) ProtoMessage()               {}
func (*QueryReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *QueryReply) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *QueryReply) GetData() map[string]*QueryReply_DataField {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *QueryReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *QueryReply) GetDepth() int64 {
	if m != nil {
		return m.Depth
	}
	return 0
}

func (m *QueryReply) GetFactName() string {
	if m != nil {
		return m.FactName
	}
	return ""
}

func (m *QueryReply) GetDecorators() []*inner.Decorator {
	if m != nil {
		return m.Decorators
	}
	return nil
}

func (m *QueryReply) GetChildren() []*QueryReply {
	if m != nil {
		return m.Children
	}
	return nil
}

type QueryReply_DataField struct {
	// Types that are valid to be assigned to Prop:
	//	*QueryReply_DataField_StringProp
	//	*QueryReply_DataField_BoolProp
	//	*QueryReply_DataField_Int64Prop
	//	*QueryReply_DataField_FloatProp
	Prop       isQueryReply_DataField_Prop `protobuf_oneof:"prop"`
	Decorators []*inner.Decorator          `protobuf:"bytes,5,rep,name=decorators" json:"decorators,omitempty"`
}

func (m *QueryReply_DataField) Reset()                    { *m = QueryReply_DataField{} }
func (m *QueryReply_DataField) String() string            { return proto.CompactTextString(m) }
func (*QueryReply_DataField) ProtoMessage()               {}
func (*QueryReply_DataField) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15, 0} }

type isQueryReply_DataField_Prop interface {
	isQueryReply_DataField_Prop()
}

type QueryReply_DataField_StringProp struct {
	StringProp string `protobuf:"bytes,1,opt,name=stringProp,oneof"`
}
type QueryReply_DataField_BoolProp struct {
	BoolProp bool `protobuf:"varint,2,opt,name=boolProp,oneof"`
}
type QueryReply_DataField_Int64Prop struct {
	Int64Prop int64 `protobuf:"varint,3,opt,name=int64Prop,oneof"`
}
type QueryReply_DataField_FloatProp struct {
	FloatProp float32 `protobuf:"fixed32,4,opt,name=floatProp,oneof"`
}

func (*QueryReply_DataField_StringProp) isQueryReply_DataField_Prop() {}
func (*QueryReply_DataField_BoolProp) isQueryReply_DataField_Prop()   {}
func (*QueryReply_DataField_Int64Prop) isQueryReply_DataField_Prop()  {}
func (*QueryReply_DataField_FloatProp) isQueryReply_DataField_Prop()  {}

func (m *QueryReply_DataField) GetProp() isQueryReply_DataField_Prop {
	if m != nil {
		return m.Prop
	}
	return nil
}

func (m *QueryReply_DataField) GetStringProp() string {
	if x, ok := m.GetProp().(*QueryReply_DataField_StringProp); ok {
		return x.StringProp
	}
	return ""
}

func (m *QueryReply_DataField) GetBoolProp() bool {
	if x, ok := m.GetProp().(*QueryReply_DataField_BoolProp); ok {
		return x.BoolProp
	}
	return false
}

func (m *QueryReply_DataField) GetInt64Prop() int64 {
	if x, ok := m.GetProp().(*QueryReply_DataField_Int64Prop); ok {
		return x.Int64Prop
	}
	return 0
}

func (m *QueryReply_DataField) GetFloatProp() float32 {
	if x, ok := m.GetProp().(*QueryReply_DataField_FloatProp); ok {
		return x.FloatProp
	}
	return 0
}

func (m *QueryReply_DataField) GetDecorators() []*inner.Decorator {
	if m != nil {
		return m.Decorators
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QueryReply_DataField) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QueryReply_DataField_OneofMarshaler, _QueryReply_DataField_OneofUnmarshaler, _QueryReply_DataField_OneofSizer, []interface{}{
		(*QueryReply_DataField_StringProp)(nil),
		(*QueryReply_DataField_BoolProp)(nil),
		(*QueryReply_DataField_Int64Prop)(nil),
		(*QueryReply_DataField_FloatProp)(nil),
	}
}

func _QueryReply_DataField_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QueryReply_DataField)
	// prop
	switch x := m.Prop.(type) {
	case *QueryReply_DataField_StringProp:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.StringProp)
	case *QueryReply_DataField_BoolProp:
		t := uint64(0)
		if x.BoolProp {
			t = 1
		}
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *QueryReply_DataField_Int64Prop:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Int64Prop))
	case *QueryReply_DataField_FloatProp:
		b.EncodeVarint(4<<3 | proto.WireFixed32)
		b.EncodeFixed32(uint64(math.Float32bits(x.FloatProp)))
	case nil:
	default:
		return fmt.Errorf("QueryReply_DataField.Prop has unexpected type %T", x)
	}
	return nil
}

func _QueryReply_DataField_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QueryReply_DataField)
	switch tag {
	case 1: // prop.stringProp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Prop = &QueryReply_DataField_StringProp{x}
		return true, err
	case 2: // prop.boolProp
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Prop = &QueryReply_DataField_BoolProp{x != 0}
		return true, err
	case 3: // prop.int64Prop
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Prop = &QueryReply_DataField_Int64Prop{int64(x)}
		return true, err
	case 4: // prop.floatProp
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Prop = &QueryReply_DataField_FloatProp{math.Float32frombits(uint32(x))}
		return true, err
	default:
		return false, nil
	}
}

func _QueryReply_DataField_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QueryReply_DataField)
	// prop
	switch x := m.Prop.(type) {
	case *QueryReply_DataField_StringProp:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.StringProp)))
		n += len(x.StringProp)
	case *QueryReply_DataField_BoolProp:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *QueryReply_DataField_Int64Prop:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int64Prop))
	case *QueryReply_DataField_FloatProp:
		n += proto.SizeVarint(4<<3 | proto.WireFixed32)
		n += 4
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The request message containing the files or directories to review.
type ReviewRequest struct {
	Host          string   `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	Hostname      string   `protobuf:"bytes,2,opt,name=hostname" json:"hostname,omitempty"`
	Owner         string   `protobuf:"bytes,3,opt,name=owner" json:"owner,omitempty"`
	Repo          string   `protobuf:"bytes,4,opt,name=repo" json:"repo,omitempty"`
	Sha           string   `protobuf:"bytes,5,opt,name=sha" json:"sha,omitempty"`
	Patches       []string `protobuf:"bytes,6,rep,name=Patches" json:"Patches,omitempty"`
	IsPullRequest bool     `protobuf:"varint,7,opt,name=isPullRequest" json:"isPullRequest,omitempty"`
	PullRequestID int64    `protobuf:"varint,8,opt,name=pullRequestID" json:"pullRequestID,omitempty"`
	Vcs           string   `protobuf:"bytes,9,opt,name=vcs" json:"vcs,omitempty"`
	Dotlingo      string   `protobuf:"bytes,10,opt,name=dotlingo" json:"dotlingo,omitempty"`
	Dir           string   `protobuf:"bytes,11,opt,name=dir" json:"dir,omitempty"`
}

func (m *ReviewRequest) Reset()                    { *m = ReviewRequest{} }
func (m *ReviewRequest) String() string            { return proto.CompactTextString(m) }
func (*ReviewRequest) ProtoMessage()               {}
func (*ReviewRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ReviewRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *ReviewRequest) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *ReviewRequest) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *ReviewRequest) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *ReviewRequest) GetSha() string {
	if m != nil {
		return m.Sha
	}
	return ""
}

func (m *ReviewRequest) GetPatches() []string {
	if m != nil {
		return m.Patches
	}
	return nil
}

func (m *ReviewRequest) GetIsPullRequest() bool {
	if m != nil {
		return m.IsPullRequest
	}
	return false
}

func (m *ReviewRequest) GetPullRequestID() int64 {
	if m != nil {
		return m.PullRequestID
	}
	return 0
}

func (m *ReviewRequest) GetVcs() string {
	if m != nil {
		return m.Vcs
	}
	return ""
}

func (m *ReviewRequest) GetDotlingo() string {
	if m != nil {
		return m.Dotlingo
	}
	return ""
}

func (m *ReviewRequest) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

// Issue returned from a review.
type Issue struct {
	// The name of the issue.
	Name          string            `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Position      *IssueRange       `protobuf:"bytes,2,opt,name=position" json:"position,omitempty"`
	Comment       string            `protobuf:"bytes,3,opt,name=comment" json:"comment,omitempty"`
	CtxBefore     string            `protobuf:"bytes,4,opt,name=ctxBefore" json:"ctxBefore,omitempty"`
	LineText      string            `protobuf:"bytes,5,opt,name=lineText" json:"lineText,omitempty"`
	CtxAfter      string            `protobuf:"bytes,6,opt,name=ctxAfter" json:"ctxAfter,omitempty"`
	Metrics       map[string]string `protobuf:"bytes,7,rep,name=metrics" json:"metrics,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Tags          []string          `protobuf:"bytes,8,rep,name=tags" json:"tags,omitempty"`
	Link          string            `protobuf:"bytes,9,opt,name=link" json:"link,omitempty"`
	NewCode       bool              `protobuf:"varint,10,opt,name=newCode" json:"newCode,omitempty"`
	Patch         string            `protobuf:"bytes,11,opt,name=patch" json:"patch,omitempty"`
	Err           string            `protobuf:"bytes,12,opt,name=err" json:"err,omitempty"`
	Discard       bool              `protobuf:"varint,13,opt,name=discard" json:"discard,omitempty"`
	DiscardReason string            `protobuf:"bytes,14,opt,name=discardReason" json:"discardReason,omitempty"`
}

func (m *Issue) Reset()                    { *m = Issue{} }
func (m *Issue) String() string            { return proto.CompactTextString(m) }
func (*Issue) ProtoMessage()               {}
func (*Issue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Issue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Issue) GetPosition() *IssueRange {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Issue) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Issue) GetCtxBefore() string {
	if m != nil {
		return m.CtxBefore
	}
	return ""
}

func (m *Issue) GetLineText() string {
	if m != nil {
		return m.LineText
	}
	return ""
}

func (m *Issue) GetCtxAfter() string {
	if m != nil {
		return m.CtxAfter
	}
	return ""
}

func (m *Issue) GetMetrics() map[string]string {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *Issue) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Issue) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *Issue) GetNewCode() bool {
	if m != nil {
		return m.NewCode
	}
	return false
}

func (m *Issue) GetPatch() string {
	if m != nil {
		return m.Patch
	}
	return ""
}

func (m *Issue) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

func (m *Issue) GetDiscard() bool {
	if m != nil {
		return m.Discard
	}
	return false
}

func (m *Issue) GetDiscardReason() string {
	if m != nil {
		return m.DiscardReason
	}
	return ""
}

type IssueRange struct {
	Start *Position `protobuf:"bytes,1,opt,name=start" json:"start,omitempty"`
	End   *Position `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *IssueRange) Reset()                    { *m = IssueRange{} }
func (m *IssueRange) String() string            { return proto.CompactTextString(m) }
func (*IssueRange) ProtoMessage()               {}
func (*IssueRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *IssueRange) GetStart() *Position {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *IssueRange) GetEnd() *Position {
	if m != nil {
		return m.End
	}
	return nil
}

type Position struct {
	Filename string `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
	Offset   int64  `protobuf:"varint,2,opt,name=Offset" json:"Offset,omitempty"`
	Line     int64  `protobuf:"varint,3,opt,name=Line" json:"Line,omitempty"`
	Column   int64  `protobuf:"varint,4,opt,name=Column" json:"Column,omitempty"`
}

func (m *Position) Reset()                    { *m = Position{} }
func (m *Position) String() string            { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()               {}
func (*Position) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Position) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *Position) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Position) GetLine() int64 {
	if m != nil {
		return m.Line
	}
	return 0
}

func (m *Position) GetColumn() int64 {
	if m != nil {
		return m.Column
	}
	return 0
}

type LatestClientVersionRequest struct {
}

func (m *LatestClientVersionRequest) Reset()                    { *m = LatestClientVersionRequest{} }
func (m *LatestClientVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*LatestClientVersionRequest) ProtoMessage()               {}
func (*LatestClientVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

type LatestClientVersionReply struct {
	Version string `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
}

func (m *LatestClientVersionReply) Reset()                    { *m = LatestClientVersionReply{} }
func (m *LatestClientVersionReply) String() string            { return proto.CompactTextString(m) }
func (*LatestClientVersionReply) ProtoMessage()               {}
func (*LatestClientVersionReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *LatestClientVersionReply) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func init() {
	proto.RegisterType((*DescribeFactRequest)(nil), "codelingo.DescribeFactRequest")
	proto.RegisterType((*DescribeFactReply)(nil), "codelingo.DescribeFactReply")
	proto.RegisterType((*Property)(nil), "codelingo.Property")
	proto.RegisterType((*PathsFromOffsetRequest)(nil), "codelingo.PathsFromOffsetRequest")
	proto.RegisterType((*PathsFromOffsetReply)(nil), "codelingo.PathsFromOffsetReply")
	proto.RegisterType((*Path)(nil), "codelingo.Path")
	proto.RegisterType((*ListFactsRequest)(nil), "codelingo.ListFactsRequest")
	proto.RegisterType((*FactList)(nil), "codelingo.FactList")
	proto.RegisterType((*Children)(nil), "codelingo.Children")
	proto.RegisterType((*ListLexiconsRequest)(nil), "codelingo.ListLexiconsRequest")
	proto.RegisterType((*ListLexiconsReply)(nil), "codelingo.ListLexiconsReply")
	proto.RegisterType((*SessionRequest)(nil), "codelingo.SessionRequest")
	proto.RegisterType((*SessionReply)(nil), "codelingo.SessionReply")
	proto.RegisterType((*QueryRequest)(nil), "codelingo.QueryRequest")
	proto.RegisterType((*MetaDatum)(nil), "codelingo.MetaDatum")
	proto.RegisterType((*QueryReply)(nil), "codelingo.QueryReply")
	proto.RegisterType((*QueryReply_DataField)(nil), "codelingo.QueryReply.DataField")
	proto.RegisterType((*ReviewRequest)(nil), "codelingo.ReviewRequest")
	proto.RegisterType((*Issue)(nil), "codelingo.Issue")
	proto.RegisterType((*IssueRange)(nil), "codelingo.IssueRange")
	proto.RegisterType((*Position)(nil), "codelingo.Position")
	proto.RegisterType((*LatestClientVersionRequest)(nil), "codelingo.LatestClientVersionRequest")
	proto.RegisterType((*LatestClientVersionReply)(nil), "codelingo.LatestClientVersionReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CodeLingo service

type CodeLingoClient interface {
	// Initialise session
	Session(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*SessionReply, error)
	// Reviews files
	Review(ctx context.Context, opts ...grpc.CallOption) (CodeLingo_ReviewClient, error)
	// Queries source code
	Query(ctx context.Context, opts ...grpc.CallOption) (CodeLingo_QueryClient, error)
	// Lists available lexicons
	ListLexicons(ctx context.Context, in *ListLexiconsRequest, opts ...grpc.CallOption) (*ListLexiconsReply, error)
	ListFacts(ctx context.Context, in *ListFactsRequest, opts ...grpc.CallOption) (*FactList, error)
	PathsFromOffset(ctx context.Context, in *PathsFromOffsetRequest, opts ...grpc.CallOption) (*PathsFromOffsetReply, error)
	DescribeFact(ctx context.Context, in *DescribeFactRequest, opts ...grpc.CallOption) (*DescribeFactReply, error)
	// Return the latest client version for this platform
	LatestClientVersion(ctx context.Context, in *LatestClientVersionRequest, opts ...grpc.CallOption) (*LatestClientVersionReply, error)
}

type codeLingoClient struct {
	cc *grpc.ClientConn
}

func NewCodeLingoClient(cc *grpc.ClientConn) CodeLingoClient {
	return &codeLingoClient{cc}
}

func (c *codeLingoClient) Session(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*SessionReply, error) {
	out := new(SessionReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/Session", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) Review(ctx context.Context, opts ...grpc.CallOption) (CodeLingo_ReviewClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CodeLingo_serviceDesc.Streams[0], c.cc, "/codelingo.CodeLingo/Review", opts...)
	if err != nil {
		return nil, err
	}
	x := &codeLingoReviewClient{stream}
	return x, nil
}

type CodeLingo_ReviewClient interface {
	Send(*ReviewRequest) error
	Recv() (*Issue, error)
	grpc.ClientStream
}

type codeLingoReviewClient struct {
	grpc.ClientStream
}

func (x *codeLingoReviewClient) Send(m *ReviewRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *codeLingoReviewClient) Recv() (*Issue, error) {
	m := new(Issue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *codeLingoClient) Query(ctx context.Context, opts ...grpc.CallOption) (CodeLingo_QueryClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CodeLingo_serviceDesc.Streams[1], c.cc, "/codelingo.CodeLingo/Query", opts...)
	if err != nil {
		return nil, err
	}
	x := &codeLingoQueryClient{stream}
	return x, nil
}

type CodeLingo_QueryClient interface {
	Send(*QueryRequest) error
	Recv() (*QueryReply, error)
	grpc.ClientStream
}

type codeLingoQueryClient struct {
	grpc.ClientStream
}

func (x *codeLingoQueryClient) Send(m *QueryRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *codeLingoQueryClient) Recv() (*QueryReply, error) {
	m := new(QueryReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *codeLingoClient) ListLexicons(ctx context.Context, in *ListLexiconsRequest, opts ...grpc.CallOption) (*ListLexiconsReply, error) {
	out := new(ListLexiconsReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/ListLexicons", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) ListFacts(ctx context.Context, in *ListFactsRequest, opts ...grpc.CallOption) (*FactList, error) {
	out := new(FactList)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/ListFacts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) PathsFromOffset(ctx context.Context, in *PathsFromOffsetRequest, opts ...grpc.CallOption) (*PathsFromOffsetReply, error) {
	out := new(PathsFromOffsetReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/PathsFromOffset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) DescribeFact(ctx context.Context, in *DescribeFactRequest, opts ...grpc.CallOption) (*DescribeFactReply, error) {
	out := new(DescribeFactReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/DescribeFact", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) LatestClientVersion(ctx context.Context, in *LatestClientVersionRequest, opts ...grpc.CallOption) (*LatestClientVersionReply, error) {
	out := new(LatestClientVersionReply)
	err := grpc.Invoke(ctx, "/codelingo.CodeLingo/LatestClientVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CodeLingo service

type CodeLingoServer interface {
	// Initialise session
	Session(context.Context, *SessionRequest) (*SessionReply, error)
	// Reviews files
	Review(CodeLingo_ReviewServer) error
	// Queries source code
	Query(CodeLingo_QueryServer) error
	// Lists available lexicons
	ListLexicons(context.Context, *ListLexiconsRequest) (*ListLexiconsReply, error)
	ListFacts(context.Context, *ListFactsRequest) (*FactList, error)
	PathsFromOffset(context.Context, *PathsFromOffsetRequest) (*PathsFromOffsetReply, error)
	DescribeFact(context.Context, *DescribeFactRequest) (*DescribeFactReply, error)
	// Return the latest client version for this platform
	LatestClientVersion(context.Context, *LatestClientVersionRequest) (*LatestClientVersionReply, error)
}

func RegisterCodeLingoServer(s *grpc.Server, srv CodeLingoServer) {
	s.RegisterService(&_CodeLingo_serviceDesc, srv)
}

func _CodeLingo_Session_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).Session(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/Session",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).Session(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_Review_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CodeLingoServer).Review(&codeLingoReviewServer{stream})
}

type CodeLingo_ReviewServer interface {
	Send(*Issue) error
	Recv() (*ReviewRequest, error)
	grpc.ServerStream
}

type codeLingoReviewServer struct {
	grpc.ServerStream
}

func (x *codeLingoReviewServer) Send(m *Issue) error {
	return x.ServerStream.SendMsg(m)
}

func (x *codeLingoReviewServer) Recv() (*ReviewRequest, error) {
	m := new(ReviewRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CodeLingo_Query_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CodeLingoServer).Query(&codeLingoQueryServer{stream})
}

type CodeLingo_QueryServer interface {
	Send(*QueryReply) error
	Recv() (*QueryRequest, error)
	grpc.ServerStream
}

type codeLingoQueryServer struct {
	grpc.ServerStream
}

func (x *codeLingoQueryServer) Send(m *QueryReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *codeLingoQueryServer) Recv() (*QueryRequest, error) {
	m := new(QueryRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CodeLingo_ListLexicons_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLexiconsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).ListLexicons(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/ListLexicons",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).ListLexicons(ctx, req.(*ListLexiconsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_ListFacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).ListFacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/ListFacts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).ListFacts(ctx, req.(*ListFactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_PathsFromOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathsFromOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).PathsFromOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/PathsFromOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).PathsFromOffset(ctx, req.(*PathsFromOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_DescribeFact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeFactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).DescribeFact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/DescribeFact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).DescribeFact(ctx, req.(*DescribeFactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_LatestClientVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestClientVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).LatestClientVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/codelingo.CodeLingo/LatestClientVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).LatestClientVersion(ctx, req.(*LatestClientVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CodeLingo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "codelingo.CodeLingo",
	HandlerType: (*CodeLingoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Session",
			Handler:    _CodeLingo_Session_Handler,
		},
		{
			MethodName: "ListLexicons",
			Handler:    _CodeLingo_ListLexicons_Handler,
		},
		{
			MethodName: "ListFacts",
			Handler:    _CodeLingo_ListFacts_Handler,
		},
		{
			MethodName: "PathsFromOffset",
			Handler:    _CodeLingo_PathsFromOffset_Handler,
		},
		{
			MethodName: "DescribeFact",
			Handler:    _CodeLingo_DescribeFact_Handler,
		},
		{
			MethodName: "LatestClientVersion",
			Handler:    _CodeLingo_LatestClientVersion_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Review",
			Handler:       _CodeLingo_Review_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Query",
			Handler:       _CodeLingo_Query_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "github.com/codelingo/lingo/service/grpc/codelingo/codelingo.proto",
}

func init() {
	proto.RegisterFile("github.com/codelingo/lingo/service/grpc/codelingo/codelingo.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1393 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x57, 0x5b, 0x6f, 0xdc, 0x44,
	0x14, 0x5e, 0xef, 0x2d, 0xde, 0x93, 0x4d, 0x9b, 0x4e, 0xd2, 0xd6, 0x98, 0xd0, 0x2e, 0x86, 0x4a,
	0x01, 0xa4, 0xa4, 0x37, 0x2e, 0xaa, 0x54, 0x95, 0x36, 0xa1, 0x6a, 0xa5, 0xb4, 0xa4, 0x06, 0x95,
	0x3e, 0x21, 0x39, 0xf6, 0x6c, 0x76, 0xa8, 0xd7, 0x76, 0x67, 0x66, 0xb7, 0xd9, 0x3f, 0xc0, 0x2b,
	0x2f, 0xfc, 0x01, 0xf8, 0x2f, 0x48, 0xfc, 0x09, 0x5e, 0xf9, 0x1d, 0xe8, 0xcc, 0xc5, 0x6b, 0xef,
	0x6e, 0xda, 0x17, 0x5e, 0x92, 0x73, 0xf3, 0xcc, 0x39, 0xdf, 0x9c, 0xdb, 0xc2, 0xc3, 0x53, 0x26,
	0x47, 0x93, 0x93, 0xbd, 0x38, 0x1f, 0xef, 0xc7, 0x79, 0x42, 0x53, 0x96, 0x9d, 0xe6, 0xfb, 0xfa,
	0xaf, 0xa0, 0x7c, 0xca, 0x62, 0xba, 0x7f, 0xca, 0x8b, 0xb8, 0xa2, 0x2c, 0xa9, 0xbd, 0x82, 0xe7,
	0x32, 0x27, 0xbd, 0x52, 0xe0, 0x7f, 0xb1, 0xf2, 0xb4, 0x38, 0x7d, 0x93, 0xee, 0xb3, 0x2c, 0xa3,
	0x5c, 0xff, 0xd5, 0xdf, 0x05, 0x63, 0xd8, 0x3a, 0xa4, 0x22, 0xe6, 0xec, 0x84, 0x3e, 0x8e, 0x62,
	0x19, 0xd2, 0x37, 0x13, 0x2a, 0x24, 0xd9, 0x86, 0x4e, 0xfe, 0x36, 0xa3, 0xdc, 0x73, 0x06, 0xce,
	0x6e, 0x2f, 0xd4, 0x0c, 0x21, 0xd0, 0xce, 0xa2, 0x31, 0xf5, 0x9a, 0x4a, 0xa8, 0x68, 0xe2, 0xc1,
	0xda, 0x94, 0x72, 0xc1, 0xf2, 0xcc, 0x6b, 0x29, 0xb1, 0x65, 0xd1, 0x7a, 0x18, 0xc5, 0xd2, 0x6b,
	0x6b, 0x6b, 0xa4, 0x83, 0x5f, 0x1d, 0xb8, 0x54, 0xbf, 0xaf, 0x48, 0x67, 0x64, 0x00, 0xeb, 0x89,
	0x12, 0x16, 0x12, 0xcf, 0xd1, 0x77, 0x56, 0x45, 0xc4, 0x07, 0x97, 0x9e, 0x45, 0xe3, 0x22, 0xa5,
	0xc2, 0xdc, 0x5e, 0xf2, 0xe4, 0x0e, 0x40, 0xc1, 0xf3, 0x82, 0x72, 0xc9, 0xa8, 0xf0, 0x5a, 0x83,
	0xd6, 0xee, 0xfa, 0xed, 0xad, 0xbd, 0x39, 0x40, 0xc7, 0x5a, 0x39, 0x0b, 0x2b, 0x66, 0xc1, 0xb7,
	0xe0, 0x5a, 0x79, 0x19, 0x96, 0x53, 0x09, 0x6b, 0xc1, 0xa5, 0xe6, 0x92, 0x4b, 0xc1, 0xef, 0x0e,
	0x5c, 0x39, 0x8e, 0xe4, 0x48, 0x3c, 0xe6, 0xf9, 0xf8, 0xfb, 0xe1, 0x50, 0xd0, 0x12, 0x3d, 0x02,
	0xed, 0x34, 0xca, 0x4e, 0xed, 0x81, 0x48, 0x93, 0x4d, 0x68, 0x25, 0x8c, 0x9b, 0x83, 0x90, 0xc4,
	0x98, 0x86, 0x2c, 0xa5, 0xea, 0x6a, 0x0d, 0x5d, 0xc9, 0xa3, 0xb5, 0xe0, 0xb1, 0x81, 0x0e, 0x49,
	0x7c, 0x11, 0x21, 0x23, 0x2e, 0xbd, 0xce, 0xc0, 0xd9, 0x6d, 0x85, 0x9a, 0x41, 0x3b, 0x9a, 0x25,
	0x5e, 0x57, 0xc9, 0x90, 0x0c, 0xee, 0xc3, 0xf6, 0x92, 0x57, 0x88, 0xf1, 0x0d, 0xe8, 0x14, 0x28,
	0xf7, 0x1c, 0x05, 0xd0, 0xc5, 0x2a, 0x40, 0x91, 0x1c, 0x85, 0x5a, 0x1b, 0xec, 0x40, 0x1b, 0x59,
	0xbc, 0x2e, 0xcb, 0x13, 0xaa, 0xcd, 0x7b, 0xa1, 0x66, 0x82, 0x97, 0xb0, 0x79, 0xc4, 0x84, 0xc4,
	0x97, 0x13, 0xff, 0x63, 0xaa, 0x04, 0xbf, 0x39, 0xe0, 0xe2, 0xa1, 0x78, 0x38, 0xb9, 0x0b, 0x1d,
	0xcc, 0x15, 0xeb, 0xe9, 0xb5, 0x8a, 0xa7, 0xd6, 0x46, 0x11, 0xe2, 0xbb, 0x4c, 0xf2, 0x59, 0xa8,
	0x8d, 0xfd, 0x67, 0x00, 0x73, 0x21, 0xe2, 0xf2, 0x9a, 0xce, 0x8c, 0x4b, 0x48, 0x92, 0xcf, 0xa0,
	0x33, 0x8d, 0xd2, 0x89, 0xf6, 0xa8, 0x9e, 0x20, 0x07, 0x23, 0x96, 0x26, 0x9c, 0x66, 0xa1, 0xb6,
	0xb8, 0xd7, 0xfc, 0xc6, 0x09, 0x06, 0xe0, 0x5a, 0x31, 0x46, 0x18, 0x23, 0x6d, 0xb1, 0x50, 0x4c,
	0x70, 0x19, 0xb6, 0xd0, 0x95, 0x23, 0x7a, 0xc6, 0xe2, 0x3c, 0xb3, 0x70, 0x04, 0xfb, 0x70, 0xa9,
	0x2e, 0x46, 0xf0, 0x7d, 0x70, 0x53, 0x23, 0x30, 0x87, 0x94, 0x7c, 0xb0, 0x09, 0x17, 0x7e, 0xa0,
	0x02, 0x61, 0xb0, 0x47, 0x0c, 0xa0, 0x5f, 0x4a, 0xf0, 0xeb, 0xa5, 0x60, 0x82, 0xbf, 0x1d, 0xe8,
	0xbf, 0x98, 0x50, 0x3e, 0xb3, 0x8f, 0x10, 0x40, 0xe7, 0x0d, 0xf2, 0xca, 0x68, 0xfd, 0x76, 0x7f,
	0x4f, 0xd7, 0xb8, 0xb6, 0xd1, 0x2a, 0xf2, 0x10, 0xdc, 0x31, 0x95, 0x51, 0x12, 0xc9, 0xc8, 0x6b,
	0x2a, 0x68, 0x6f, 0x54, 0x40, 0xa8, 0x1e, 0xb7, 0xf7, 0xcc, 0xd8, 0x69, 0x84, 0xcb, 0xcf, 0xfc,
	0x17, 0xb0, 0x51, 0x53, 0xad, 0xc0, 0xf9, 0xf3, 0x3a, 0xce, 0xdb, 0x95, 0x2b, 0xf0, 0xd3, 0xc3,
	0x48, 0x4e, 0xc6, 0x55, 0xa0, 0x5f, 0x41, 0xaf, 0x94, 0x13, 0x0f, 0xba, 0x42, 0x72, 0x66, 0x4b,
	0xe7, 0x49, 0x23, 0x34, 0x3c, 0x21, 0xd0, 0x62, 0x99, 0x54, 0x87, 0xb6, 0x9e, 0x34, 0x42, 0x64,
	0xc8, 0x36, 0xb4, 0x4f, 0xf2, 0x3c, 0x55, 0xc9, 0xe4, 0x3e, 0x69, 0x84, 0x8a, 0x7b, 0xb4, 0x06,
	0x9d, 0x04, 0x0f, 0x0b, 0xfe, 0x6c, 0x03, 0x98, 0xa8, 0x0c, 0x8a, 0x13, 0x96, 0x58, 0x57, 0x27,
	0x2c, 0x21, 0x77, 0xa0, 0xad, 0xc0, 0xd0, 0x2d, 0xe3, 0xfa, 0x32, 0x18, 0x45, 0x3a, 0xdb, 0x3b,
	0x2c, 0x61, 0x50, 0xc6, 0x98, 0x0c, 0x94, 0xf3, 0x9c, 0x9b, 0xda, 0xd4, 0x0c, 0x4a, 0x13, 0x5a,
	0xc8, 0x91, 0xad, 0x4e, 0xc5, 0xa8, 0x0a, 0x8f, 0x62, 0xf9, 0x1c, 0x0b, 0xa1, 0x6b, 0x2a, 0xdc,
	0xf0, 0xe4, 0x26, 0x40, 0x42, 0xe3, 0x9c, 0x47, 0x32, 0xe7, 0xc2, 0x5b, 0x53, 0x2e, 0x6c, 0x9a,
	0x67, 0x3b, 0xb4, 0x8a, 0xb0, 0x62, 0x43, 0x6e, 0x81, 0x1b, 0x9b, 0x94, 0xf4, 0x5c, 0x65, 0x7f,
	0x79, 0xa5, 0xcb, 0x61, 0x69, 0xe6, 0xff, 0xe5, 0x40, 0x0f, 0x03, 0x78, 0xcc, 0x68, 0x9a, 0x90,
	0x01, 0x80, 0x46, 0x13, 0x3b, 0x5f, 0x89, 0x70, 0x45, 0x46, 0x76, 0xc0, 0x45, 0x0c, 0x95, 0xbe,
	0x69, 0x50, 0x2d, 0x25, 0xe4, 0x1a, 0xf4, 0x58, 0x26, 0xbf, 0xba, 0xab, 0xd4, 0x2d, 0xf3, 0x12,
	0x73, 0x11, 0xea, 0x87, 0x69, 0x1e, 0x49, 0xa5, 0x47, 0x78, 0x9a, 0xa8, 0x2f, 0x45, 0x0b, 0x21,
	0x77, 0xde, 0x1f, 0xf2, 0xa3, 0x2e, 0xb4, 0xb1, 0x67, 0xfb, 0xaf, 0x74, 0x18, 0xe7, 0xe5, 0xdc,
	0x97, 0xf5, 0x9c, 0x7b, 0xc7, 0x4b, 0x2a, 0x20, 0xaa, 0xe9, 0xf7, 0x47, 0x13, 0x36, 0x42, 0x3a,
	0x65, 0xf4, 0x6d, 0xa5, 0x79, 0x8f, 0x72, 0x21, 0x6d, 0xf3, 0x46, 0x1a, 0x1f, 0x12, 0xff, 0x57,
	0x3a, 0x5a, 0xc9, 0xcf, 0xfb, 0x5f, 0x6b, 0xa1, 0xff, 0x71, 0x5a, 0xe4, 0x76, 0xf8, 0x21, 0xad,
	0x9a, 0xfa, 0x28, 0x52, 0x29, 0x82, 0x4d, 0x7d, 0x14, 0x61, 0x47, 0x3c, 0x8e, 0x64, 0x3c, 0xa2,
	0xc2, 0xeb, 0xaa, 0xb6, 0x60, 0x59, 0xf2, 0x29, 0x6c, 0x30, 0x71, 0x3c, 0x49, 0x53, 0xe3, 0x96,
	0xb7, 0x86, 0xcf, 0x11, 0xd6, 0x85, 0x68, 0x55, 0xcc, 0xd9, 0xa7, 0x87, 0x9e, 0xab, 0xd2, 0xaf,
	0x2e, 0xc4, 0x7b, 0xa7, 0xb1, 0xf0, 0x7a, 0xfa, 0xde, 0x69, 0x2c, 0x30, 0x9e, 0x24, 0x97, 0x0a,
	0x21, 0x0f, 0x74, 0x3c, 0x96, 0xb7, 0x83, 0x6a, 0xbd, 0x1c, 0x54, 0xc1, 0x3f, 0x2d, 0xe8, 0x3c,
	0x15, 0x62, 0x42, 0x57, 0x4e, 0xca, 0x5b, 0xe0, 0x16, 0xb9, 0x60, 0xe5, 0x98, 0xac, 0xa7, 0xa5,
	0xfa, 0x2e, 0x8c, 0xb2, 0x53, 0x1a, 0x96, 0x66, 0x18, 0x76, 0x9c, 0x8f, 0xc7, 0x34, 0x93, 0x76,
	0x10, 0x18, 0x96, 0xec, 0x40, 0x2f, 0x96, 0x67, 0x8f, 0xe8, 0x30, 0xe7, 0xd4, 0x60, 0x37, 0x17,
	0xa8, 0x36, 0xca, 0x32, 0xfa, 0x23, 0x3d, 0x93, 0x06, 0xc5, 0x92, 0x47, 0x5d, 0x2c, 0xcf, 0x1e,
	0x0e, 0x25, 0xe5, 0xb6, 0xd6, 0x2c, 0x4f, 0xbe, 0x86, 0xb5, 0x31, 0x95, 0x9c, 0xc5, 0xb6, 0xd0,
	0x3e, 0x5a, 0xf4, 0x10, 0x7b, 0x13, 0xea, 0x75, 0xa5, 0x5b, 0x6b, 0x8c, 0x57, 0x46, 0xa7, 0x42,
	0x95, 0x5b, 0x2f, 0x54, 0xb4, 0x1a, 0xee, 0x2c, 0x7b, 0x6d, 0xe0, 0x54, 0x34, 0x06, 0x94, 0xd1,
	0xb7, 0x07, 0x79, 0x42, 0x15, 0x9c, 0x6e, 0x68, 0x59, 0xcc, 0x8e, 0x02, 0x9f, 0xd4, 0xe0, 0xa9,
	0x19, 0x35, 0xb6, 0x39, 0xf7, 0xfa, 0x1a, 0x63, 0xca, 0x39, 0x9e, 0x90, 0x30, 0x11, 0x47, 0x3c,
	0xf1, 0x36, 0xf4, 0x09, 0x86, 0xc5, 0x37, 0x36, 0x64, 0x48, 0x23, 0x91, 0x67, 0xde, 0x05, 0xf5,
	0x55, 0x5d, 0xe8, 0xdf, 0x83, 0x7e, 0x35, 0x84, 0x15, 0x45, 0xb2, 0x5d, 0x2d, 0x92, 0x5e, 0xb5,
	0x06, 0x7e, 0x06, 0x98, 0x3f, 0x13, 0x0e, 0x4a, 0xbd, 0x68, 0x38, 0x4b, 0x83, 0xf2, 0xd8, 0x3c,
	0xa0, 0xdd, 0x3e, 0x6e, 0xe8, 0xed, 0xa3, 0x79, 0xbe, 0xa1, 0x5a, 0x49, 0x7e, 0x01, 0xd7, 0x0a,
	0x6a, 0x4b, 0x8f, 0xb3, 0xb0, 0xf4, 0x5c, 0x81, 0xae, 0xde, 0x58, 0x74, 0x9b, 0x0f, 0x0d, 0x87,
	0x88, 0x1f, 0xb1, 0x4c, 0x2f, 0x49, 0xad, 0x50, 0xd1, 0x68, 0x7b, 0x90, 0xa7, 0x93, 0x71, 0xa6,
	0xb2, 0xa4, 0x15, 0x1a, 0x2e, 0xd8, 0x01, 0xff, 0x28, 0x92, 0x54, 0xc8, 0x83, 0x94, 0xd1, 0x4c,
	0xbe, 0xd4, 0x0b, 0x86, 0x9d, 0xac, 0x77, 0xc1, 0x5b, 0xa9, 0xc5, 0xf9, 0x50, 0xd9, 0x4e, 0x9c,
	0xda, 0x76, 0x72, 0xfb, 0xdf, 0x36, 0xf4, 0xf0, 0x31, 0x8f, 0x54, 0x7d, 0x3c, 0x80, 0x35, 0x33,
	0x9d, 0xc9, 0x07, 0x95, 0x90, 0xeb, 0x33, 0xdc, 0xbf, 0xba, 0x4a, 0x55, 0xa4, 0xb3, 0xa0, 0x41,
	0xee, 0x41, 0x57, 0x77, 0x1c, 0xe2, 0x55, 0x8c, 0x6a, 0x4d, 0xc8, 0xdf, 0x5c, 0x4c, 0xd0, 0xa0,
	0xb1, 0xeb, 0xdc, 0x74, 0xc8, 0x7d, 0xe8, 0xa8, 0x8e, 0x46, 0xae, 0x9e, 0x33, 0xba, 0xfd, 0xd5,
	0x33, 0xc1, 0x7c, 0xfe, 0x1c, 0xfa, 0xd5, 0xe5, 0x84, 0x54, 0x77, 0xab, 0x15, 0xcb, 0x8c, 0xbf,
	0x73, 0xae, 0x5e, 0x87, 0xf2, 0x00, 0x7a, 0xe5, 0x3e, 0x48, 0x3e, 0x5c, 0x30, 0xae, 0x6e, 0x89,
	0xfe, 0xd6, 0x8a, 0x2d, 0x2e, 0x68, 0x90, 0x9f, 0xe0, 0xe2, 0xc2, 0xb6, 0x4a, 0x3e, 0x5e, 0xd8,
	0x4c, 0x97, 0xf7, 0x6b, 0xff, 0xfa, 0xbb, 0x4c, 0xb4, 0x67, 0xcf, 0xa1, 0x5f, 0xfd, 0x9d, 0x51,
	0x8b, 0x74, 0xc5, 0x0f, 0x9e, 0x5a, 0xa4, 0x4b, 0x3f, 0x50, 0x82, 0x06, 0x89, 0x61, 0x6b, 0x45,
	0xe6, 0x90, 0xea, 0x06, 0x75, 0x7e, 0xde, 0xf9, 0x9f, 0xbc, 0xcf, 0x4c, 0x5d, 0x72, 0xd2, 0x55,
	0xbf, 0xc9, 0xee, 0xfc, 0x17, 0x00, 0x00, 0xff, 0xff, 0xfc, 0xce, 0xca, 0x2c, 0x10, 0x0e, 0x00,
	0x00,
}
